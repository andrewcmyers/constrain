<html>
<head>
  <script src="../numeric-1.2.6.js"></script>
  <script src="../constrain.js"></script>
  <style>
    canvas {
        background-color: transparent;
        max-width: 100%; width: 200px; height: 200px;
    }
    h1, h2 { font-family: Optima, sans-serif; text-align: center; color: #008 }
    h3, h4 { font-family: Optima, sans-serif; color: #008 }
    h1 { font-size: 400% }
    h2 { font-size: 300% }
    h3 { font-size: 150% }
    h4 { font-size: 120% }
    div.content { max-width: 100ex; margin: 4em auto }   
    body  {background-color: fed }
    p, ul li { font-size: 12pt; font-family: Palatino, serif }       
    pre.code { padding: 1ex; font-size: 10pt; width: 60ex; float:right; border: 1px solid black; background-color: #ddd; font-family: Menlo, fixed }

</style>
  
</head>
<body>

<script>
  function elem(id) { return document.getElementById(id) }
  function show_example(pre_id, div_id) {
    elem(pre_id).innerText = elem(div_id).outerHTML
        .replace(/^.*\n/, "")
        .replace(/<\/div>$/, "")


  }
</script>

<div class=content>
<h1>Constrain</h1>
<h2>Constraint-Based Animated Figures for Web Pages</h2>

<p>
  Constrain is designed for adding diagrams to web pages and
  web-based presentations. It has some advantages over
  alternative ways to generate diagrams:
  <ul>
    <li>Constrain draws figures onto HTML canvases, so diagrams are
        resolution-independent and as crisp as possible on all displays.
    <li>Constrain supports animated figures in which displayed objects move and change
        their appearance smoothly or discontinuously. To make animations smooth,
        it uses a fast solver based on backpropagation.
    <li>Constrain is based on declaring constraints that are automatically
        solved. This makes it is easy to produce very precise diagrams,
        and makes it easier to build and modify complex diagrams.
    <li>Constrain includes an integration for the Reveal.js web-based presentation
        framework, so you can use it for presentations too.
  </ul>
  Constrain is written in JavaScript (ECMAScript 6) and integrates into web
  pages in most modern browsers.
</p>
<p>
  This page is intended to be a reference manual for Constrain. Since it is written
  using Constrain, it is also an example of how to use it. The reference manual
  is a work in progress, so not all features are covered yet.
<h2>Overview</h2>
<p>
  Here is a very simple Constrain diagram, generated by the code on the right:
</p>

<pre id="example1_code" class=code></pre>
<div id="example1">
<canvas id=fig1>Example figure</canvas>
<script>
  with (new Constrain.Figure("fig1")) {
    setLineWidth(3)
    let sq = square(),
        c = circle().setFillStyle("#cdf")
                    .at(sq.lr())
    label("circle", 18).at(c)
  }
</script>
</div>
<script>
    show_example("example1_code", "example1")
</script>

<p>
All Constrain resources are accessed via the global <code>Constrain</code> object. For example,
the class <code>Figure</code> can be named as <code>Constrain.Figure</code>. For brevity,
the <code>Constrain.</code> qualifier is often omitted in this document.
</p>
<p>
A figure is created by instantiating the class <code>Figure</code> with the identifier
attribute of the canvas in which the figure is to appear, or with the canvas object itself.
In the example above, the canvas is named <code>"fig1"</code>, so this attribute is passed
to the <code>Figure</code> constructor.
</p>
<p>
Typically, the methods of <code>Figure</code> are used to define graphical objects to appear
in the figure, constraints to govern their size and placement, and possibly animation frame
information to specify how the graphical objects and constraints change over time. In
the example above, these methods are invoked implicitly on the new <code>Figure</code> object
because of the <code>with</code> statement; it turns out to be convenient for use with Constrain.
The <code>square</code> and <code>circle</code> methods create graphical objects to be displayed
in the figure. Both of them inherit the figure's default line width of 3; the circle overrides
the fill color to be light blue by calling <code>setFillStyle</code>. The second method call on
the circle introduces constraints to position the cricle at the lower right corner of the square.
Note that graphical objects support cascaded method calls; the result of <code>setFillStyle</code>
is simply the circle itself.
</p>

<h2>Graphical objects</h2>

<p>
Constrain supports a number of useful graphical objects that support a common
API for defining their appearance. The <code>Figure</code> class provides
convenience methods for creating these objects, although they can also be
created by invoking the constructors of the corresponding classes.  Constrain
can be extended with new user-defined graphical objects, using the full power
of HTML canvases to produce desired graphical effects. 
</p>
<p>
Graphical objects are drawn in the order in which they are declared, so objects
created later may cover those created earlier. In this respect, figures are not
fully declarative.
</p>

<h3>Shapes</h3>

<h4><code>rectangle([fillStyle], [strokeStyle], [lineWidth])</code></h4>
<p>
A rectangle object (class <code>Rectangle</code>). The default fill style, stroke style,
and line width of the figure may optionally be overridden by providing these parameters.

<pre id="rectangle_ex_code" class=code></pre>
<div id="rectangle_ex">
<canvas id=rectangle_ex_fig></canvas>
<script>
  with (new Constrain.Figure("rectangle_ex_fig")) {
    const grd = ctx.createLinearGradient(0, 0, 100, 100)
    grd.addColorStop(0, "red")
    grd.addColorStop(1, "blue")
    rectangle().setFillStyle(grd)
               .setLineWidth(4)
               .setCornerRadius(10)
  }
</script>
</div>
<script>
    show_example("rectangle_ex_code", "rectangle_ex")
</script>

<h4><code>square([fillStyle], [strokeStyle], [lineWidth])</code></h4>
<p>
A square (class <code>Square</code>), which is just a rectangle
constrained to have equal dimensions. The default fill style, stroke style, and
line width of the figure may optionally be overridden by providing these
parameters.

<h4><code>ellipse([fillStyle], [strokeStyle], [lineWidth])</code></h4>
<p>
An axis-aligned ellipse (class <code>Ellipse</code>).  The default fill
style, stroke style, and line width of the figure may optionally be overridden
by providing these parameters.

<pre id="ellipse_ex_code" class=code></pre>
<div id="ellipse_ex">
<canvas id=ellipse_ex_fig></canvas>
<script>
  with (new Constrain.Figure("ellipse_ex_fig")) {
    let e = ellipse().setFillStyle("#fde")
    equal(e.width(), times(2, e.height()),
          canvasRect().inset(2).width())
  }
</script>
</div>
<script>
    show_example("ellipse_ex_code", "ellipse_ex")
</script>

<h4><code>circle([fillStyle], [strokeStyle], [lineWidth])</code></h4>
<p>
A circle object (class <code>Circle</code>), which is just an ellipse
constrained to have equal dimensions. The default fill style, stroke style, and
line width of the figure may optionally be overridden by providing these
parameters.

<h4><code>polygon(points, [fillStyle], [strokeStyle], [lineWidth])</code></h4>
<p>
A closed polygon connecting the given array of points (class <code>Polygon</code>).

<pre id="polygon_ex_code" class=code></pre>
<div id="polygon_ex">
<canvas id=polygon_ex_fig></canvas>
<script>
  with (new Constrain.Figure("polygon_ex_fig")) {
    let p1 = point(), p2 = point(), p3 = point()
    equal(100, distance(p1, p2),
          distance(p2, p3), distance(p1, p3))
    equal(p2.y(), p3.y())
    polygon([p1, p2, p3], "#dfd")
  }
</script>
</div>
<script>
    show_example("polygon_ex_code", "polygon_ex")
</script>

<h3>Lines</h3>

<h4><code>line([strokeStyle], [lineWidth])</code></h4>
<p>
Creates a straight line whose appearance can be overridden with optional
parameters (class <code>Line</code>).  Its position is defined by adding constraints on the points
returned by its <code>p1()</code> and <code>p2()</code> methods. It can also be
given arrowheads.
</p>

<h4><code>horzLine([strokeStyle], [lineWidth])</code></h4>
<p>
Creates a straight horizontal line (class <code>HorzLine<code>).
</p>

<h4><code>vertLine([strokeStyle], [lineWidth])</code></h4>
<p>
Creates a straight vertical line (class <code>VertLine<code>).
</p>

<h4><code>connector(...objects)</code></h4>
<p>
Connectors (class <code>Connector</code>) are often the easiest way to draw a line. A connector is a smooth
curve connecting the specified list of objects. Typically, the goal is to
connect the objects at the beginning and end of the list, with the intermediate
objects (often <code>Point</code>s) serving as control points to guide the
shape of the curve. Connectors act like Bezier splines near their endpoints but
like B-splines (which are smoother) in the middle. 
</p>

<pre id="connector_ex_code" class=code></pre>
<div id="connector_ex">
<canvas id=connector_ex_fig></canvas>
<script>
  with (new Constrain.Figure("connector_ex_fig")) {
    let c1 = circle().setW(30).at(point(30, 100)),
        c2 = circle().setW(30).at(c1.toRight(100))
    connector(c1, average(c1, c2).toTop(20), c2)
        .setEndArrow("arrow")
  }
</script>
</div>
<script>
    show_example("connector_ex_code", "connector_ex")
</script>

<h3>Text</h3>

<h4><code>label(text, [fontSize], [fontName], [fillStyle])</code></h4>
<p>
Creates a graphical object that is a simple line of text.
</p>

<h4><code>textFrame(text, [fillStyle])</code></h4>
<p>
Creates a graphical object that is a box containing text. The text is automatically reformatted
to fit within the box. Note that several other graphical objects, such as rectangles and circles,
support adding text with similar formatting capability.
</p>

<h4><code>lineLabel(text, position, [offset], [fontSize], [fontName], [fillStyle])</code></h4>
<p>
Creates a label containing the given text, positioned somewhere along a line or connector. The
position is a number from 0 to 1, representing how far along the connector the label is placed.
The optional <code>offset</code> parameter specifies how far to the starboard
side of the connector the label is placed.  It is added to a connector using the connector's
<code>addLabel</code> method.
</p>
<pre id="linelabel_ex_code" class=code></pre>
<div id="linelabel_ex">
<canvas id=linelabel_ex_fig></canvas>
<script>
  with (new Constrain.Figure("linelabel_ex_fig")) {
    let c1 = square().setW(30).at(point(30, 100)),
        c2 = square().setW(30).at(c1.toRight(100))
    connector(c1, average(c1, c2).toTop(20), c2)
        .setEndArrow("arrow")
        .addLabel(lineLabel("label", 0.5, 5))
  }
</script>
</div>
<script>
    show_example("linelabel_ex_code", "linelabel_ex")
</script>

<h3>Interactive objects</h3>

<h4><code>handle(style)</code></h4>
<p>
A handle (class <code>Handle</code>) is an object that can be moved using the mouse,
affecting any constraints that depend on its position. The following example constrains
distances to dynamically circumscribe a triangle;
you can draw the diamond-shaped handle to change the figure.
</p>

<pre id="handle_ex_code" class=code></pre>
<div id="handle_ex">
<canvas id=handle_ex_fig></canvas>
<script>
  with (new Constrain.Figure("handle_ex_fig")) {
    let c = circle("#def"), h1 = handle(),
        h2 = point(150, 150), h3 = point(50, 150)
    h1.x().setHint(20); h1.y().setHint(20)
    polygon([h1, h2, h3])
    equal(distance(c, h1), distance(c, h2),
          distance(c, h3))
    c.setW(times(2, distance(c, h1)))
  }
</script>
</div>
<script>
    show_example("handle_ex_code", "handle_ex")
</script>


<h4><code>advanceButton()</code></h4>
<p>
A button that can be used to advance the current state of the animation.
</p>

<pre id="advance_ex_code" class=code></pre>
<div id="advance_ex">
<canvas id=advance_ex_fig></canvas>
<script>
  with (new Constrain.Figure("advance_ex_fig")) {
    const f0 = addFrame(), f1 = addFrame(),
          f2 = addFrame(), f3 = addFrame()
    setRepeat(true); setFadeColor("#fed")
    setFillStyle("yellow")
    group(drawAfter(f1, square().addText("1")),
          drawAfter(f2, square().addText("2")),
          drawAfter(f3, square().addText("3")))
      .setH(30)
      .align("abut", "top bottom")
    align("right", "bottom",
          advanceButton(), canvasRect().inset(2))
  }
</script>
</div>
<script>
    show_example("advance_ex_code", "advance_ex")
</script>

<h3>Unrendered objects</h3>
<p>
Some figure elements act like graphical objects in most respects but do not result in 
any rendering. These objects are useful for positioning other objects.
</p>

<h4><code>point()</code></h4>
<p>
Creates a point (class <code>Point</code>) at an unspecified location. Its
location is solved for.
</p>

<h4><code>point(x, y)</code></h4>
<p>
Creates a point (class <code>Point</code>) at the location (x,y). This is
equivalent to <code>point().at(x,y)
</p>

<h4><code>box()</code></h4>
<p>
A box (class <code>Box</code>) is an axis-aligned rectangle that has no
rendering. In other respects it acts like a graphical object; for example, it
has a width and height.
</p>

<h4><code>hspace(w)</code></h4>
<p>
Horizontal space. It has width <code>w</code> but zero height.
</p>

<h4><code>vspace(h)</code></h4>
<p>
Vertical space. It has height <code>h</code> but zero width.
</p>

<h4><code>DOMElement(id)</code></h4>
<p>
A box with position and the size of the DOM element with the specified id
attribute (class <code>DOMElementBox</code>).  This feature helps overlay
graphics onto regular web page content.
</p>

<h4><code>canvasRect()</code></h4>
<p>
A box exactly filling the canvas the figure is drawn in, which is useful for
positioning objects relative to the canvas.
</p>

<h4><code>group(...objects)</code></h4>
<p>
A box containing a set of objects. The box is just large enough to surround all the objects.
</p>
<h4><code>variable(name)</code></h4>
<p>
Creates a fresh variable that can be solved for. Its name is based on the <code>name</code>
parameter.
</p>

<h3>User-defined graphical objects</h3>
<p>
The class <code>UserDefined</code> provides a template for building new graphical objects.
By default, a user-defined object is drawn as a plain gray square.
It is the responsibility of the user to define a subclass of <code>UserDefined</code>, in
which the following method is overridden:

<h4><code>draw(context, frame, time, x0, y0, x1, y1)</code></h4>

<p>
Draw a user-defined object in the graphical context <code>context</code>. The current
animation frame is <code>frame</code> and the time (0–1) within that frame is <code>time</code>.
The parameters <code>x0</code>, <code>y0</code>, <code>x1</code>, <code>y1</code> define the
box that nominally contains the object.
</p>
<h2>Figure control</h2>
<p>
Figure objects offer some methods for controlling the figure as a whole:

<h4><code>start()</code></h4>

<p>Requests the figure to start rendering when it is ready.
Figures do not automatically appear; for example, this document
ends with a loop over the list of all figures (<code>Constrain.Figures</code),
telling each one to start.
</p>

<h4><code>stop()</code></h4>

<p>Clears the figure and moves it back to an unready status.</p>

<h4><code>destroy()</code></h4>

<p>Destroys the figure and removes it from the list of figures (<code>Constrain.Figures</code>).</p>

<h3>Default styles</h3>

<p>
Graphical objects can set their own style, but if no style is specified, the style is inherited
from the figure. The following figure methods support defining the default styles.
</p>

<h4><code>setFillStyle(style)</code></h4>
<h4><code>setStrokeStyle(style)</code></h4>
<h4><code>setLineWidth(w)</code></h4>
<h4><code>setFontSize(s)</code></h4>
<h4><code>setFontName(n)</code></h4>

<h2>Constraints</h2>

<p>
The appearance of a figure is governed by a set of constraints. Some graphical objects
automatically add their own constraints to the set. Additional constraints can be added
by methods on the figure object.
</p>

<h4><code>align(horizontal, vertical, ...objs)</code></h4>
<p>
Aligns the objects in the list <code>objs</code> according to the alignment specification
given by the strings <code>horizontal</code> and <code>vertical</code>. Objects may be
passed either as a single array of objects or as a variable-length list of arguments.
The horizontal alignment specification can be any of the following:
</p>
<ul>
<li><code>"none"</code>: No horizontal alignment
<li><code>"left"</code>: Align left sides
<li><code>"right"</code>: Align right sides
<li><code>"center"</code>: Align horizontal centers
<li><code>"left right"</code>: Align both left and right sides, forcing the objects to have the
                same width.
<li><code>"abut"</code>: Make objects abut each other directly, left-to-right. Space may be inserted
            between the objects using the method <code>hspace()</code>.
<li><code>"distribute"</code>: Equalize the horizontal separation between the objects in the list.
</ul>
<p>
The vertical alignment specification is the same as the horizontal specification, except
that <code>top</code> and <code>bottom</code> replace <code>left</code> and <code>right</code>.
</p>

<h4><code>equal(...e)</code></h4>
<p>
Adds a constraint that the expressions in the list <code>e</code> are all equal to each other.
</p>

<h4><code>geq(...e)</code></h4>
<p>
Adds a constraint that each expression in the list <code>e</code> is greater than or equal to
those later in the list.
</p>

<h4><code>nearZero(e)</code></h4>
<p>A constraint that expression <code>e</code> is as close to zero as possible.</p>

<h4><code>positive(e)</code></h4>
<p>
Adds a constraint that the expression <code>e</code> is greater than or equal to zero.
</p>

<h4><code>leq(...e)</code></h4>
<p>
Adds a constraint that each expression in the list <code>e</code> is less than or equal to the next.
</p>

<h4><code>pin(...o)</code></h4>
<p>
Adds a constraint that all the objects in the list <code>o</code> are located at the same position.
</p>

<h4><code>collinear(p0, p1, p2)</code></h4>
<p>
Adds a constraint that the points <code>p0</code>, <code>p1</code>, <code>p2</code> all lie in
a straight line.
</p>

<h4><code>constraintGroup(...constraints)</code></h4>
<p>Adds a constraint that all of the supplied constraints are satisfied.</p>

<h3>Expressions</h3>
<p>
Some constraints are built out of expressions. The following expressions are
supported by the constraint solver. Expressions may have a either a scalar
value (a number) or an array value. For example, as an expressoin, a point
evaluates to a two-element array, and any graphical objects evaluates similarly
to its center position.  Many operations can be performed either on scalars or
arrays.

<h4><code>plus(a, b)</code></h4>
<p>The sum of <code>a</code> and <code>b</code>, which may be scalars or arrays.
</p>

<h4><code>minus(a, b)</code></h4>
<p>The difference of <code>a</code> and <code>b</code>, which may be scalars or arrays.
</p>

<h4><code>times(a, b)</code></h4>
<p>The product of <code>a</code> and <code>b</code>, at least one of which must be a
scalar.
</p>

<h4><code>divide(a, b)</code></h4>
<p>Dividing <code>a</code> by <code>b</code>. The divisor must be a scalar.
</p>

<h4><code>abs(a)</code></h4>
<p>The absolute value of <code>a</code>.</p>

<h4><code>sqrt(a)</code></h4>
<p>The square root of <code>a</code>.</p>

<h4><code>sqr(a)</code></h4>
<p>The square of <code>a</code>.</p>

<h4><code>average(a, b)</code></h4>
<p>The average of the arguments, which may be arrays of the same length.</p>

<h4><code>distance(p1, p2)</code></h4>
<p>The Euclidean distance between points <code>p1</code> and <code>p2</code>.

<h4><code>max(a, b, ...)</code></h4>
<p>The maximum of the arguments, which must all be scalars.</p>
</p>

<h4><code>min(a, b, ...)</code></h4>
<p>The minimum of the arguments, which must all be scalars.</p>
</p>

<h2>Positions</h2>

<h2>Animation</h2>

<p>
A figure has one or more <i>frames</i> that can differ in what
objects and constraints are operative during each frame.

<h3>Figure methods for animation</h3>

<p>By default, a figure has a single frame, but new frames can be added, creating
an animation that can be controlled using an <code>AdvanceButton</code> or by other
programmatic means.</p>

<h4><code>addFrame(...names)</code></h4>

<p>Adds one or more frames to the figure. Names may optionally be supplied for the frames.</p>

<h4><code>reset()</code></h4>
<p>Resets this figure back to its first frame.</p>

<h4><code>advance()</code></h4>
<p>Advances this figure to the next frame, if any. Returns true if
there is a next frame to go to.</p>

<h4><code>rewind()</code></h4>
<p>Rewinds this figure to the previous frame, if any.
Returns true if there is a previous frame to go to.</p>

<h4><code>setRepeat(f)</code></h4>
<p>Set whether the figure resets to the first frame when it
advances past the last frame.
</p>

<h4><code>setFadeColor(c)</code></h4>
<p>
For repeating figures, there is a period in which the figure
fades out to a color (by default, white). If the fade color is
set to the background color of the page, the fade effect will
be effective.
</p>

<h4><code>setAnimatedSolving(t)</code></h4>
<p>
The constraint solver does not show its solving process by default.
If this method is called with <code>true</code>, the steps the solver takes
are shown as an animation. This can be useful for visualization or debugging.
</p>

<h3>Animating graphical objects</h3>

<p>
By default, graphical objects and constraints exist for the entire duration of a figure.
However, objects and constraints can be wrapped in frame filters that make them exist
or be visible only some of the time. Convenience methods in <code>Figure</code> make these
easy to use.
</p>

<h2>Graphs</h2>

</div>

<script>
  for (f in Constrain.Figures) {
    Constrain.Figures[f].start()
  }
</script>

</body>
</html>
