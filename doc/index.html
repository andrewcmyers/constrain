<html>
<head>
  <script src="../numeric-1.2.6.js"></script>
  <script src="../constrain.js"></script>
  <style>
    canvas {
        background-color: transparent;
        max-width: 100%; width: 200px; height: 200px;
    }
    h1, h2 { font-family: Optima, sans-serif; text-align: center; color: #008 }
    h1 > small { font-size: 50% }
    h3, h4 { font-family: Optima, sans-serif; color: #008 }
    h1 { font-size: 400%; font-weight: 666; }
    h2 { font-size: 300%; page-break-after: avoid }
    h3 { font-size: 150% }
    h4 { font-size: 95%; font-family: Menlo, Consolas, fixed }
    div.content { max-width: 100ex; margin: 4em auto }   
    body  {background-color: fed }
    p, ul li { font-size: 12pt; font-family: Georgia, serif }       
    pre.code { padding: 1ex; font-size: 10pt; width: 60ex; float:right; border: 1px solid black; background-color: #ddd; font-family: Menlo, fixed }
    code { font-family: Menlo, fixed; font-size: 90% }
    @media print {
        pre.code {
            page-break-inside: avoid;
        }
    }

</style>
  
</head>
<body>

<script>
  function elem(id) { return document.getElementById(id) }
  function show_example(pre_id, div_id) {
    elem(pre_id).innerText = elem(div_id).outerHTML
        .replace(/^.*\n/, "")
        .replace(/<\/div>$/, "")


  }
</script>

<div class=content>
<h1>Constrain<br>
<small>Constraint-Based Animated Figures for Web Pages</small></h1>

<p>
  Constrain is designed for adding diagrams to web pages and
  web-based presentations. It has some advantages over
  alternative ways to generate diagrams:
  <ul>
    <li>Constrain draws figures onto HTML canvases, so diagrams are
        resolution-independent and as crisp as possible on all displays.
    <li>Constrain supports animated figures in which displayed objects move and change
        their appearance smoothly or discontinuously. To make animations smooth,
        it uses a fast solver based on backpropagation.
    <li>Constrain is based on declaring constraints that are automatically
        solved. This makes it is easy to produce very precise diagrams,
        and makes it easier to build and modify complex diagrams.
    <li>Constrain includes an integration for the Reveal.js web-based presentation
        framework, so you can use it for presentations too.
  </ul>
<p>
  Constrain is written in JavaScript (ECMAScript 6) and integrates into web
  pages in most modern browsers.
</p>
<p>
  This page is intended to be a reference manual for Constrain. Since it is written
  using Constrain, it is also an example of how to use it. The reference manual
  is a work in progress, so not all features are covered yet.
</p>
<p>
  Constrain can be obtained at its
  <a href="https://github.com/andrewcmyers/constrain">GitHub repository</a>.
</p>
<h2>Overview</h2>
<p>
  Here is a very simple Constrain diagram, generated by the code on the right:
</p>

<pre  id="example1_code" class=code></pre>
<div  id="example1">
<canvas id=fig1>Example figure</canvas>
<script>
  with (new Constrain.Figure("fig1")) {
    setLineWidth(3)
    let sq = square(),
        c = circle().setFillStyle("#cdf")
                    .at(sq.lr())
    label("circle", 18).at(c)
  }
</script>
</div>
<script>
    show_example("example1_code", "example1")
</script>

<p>
All Constrain resources are accessed via the global <code>Constrain</code> object. For example,
the class <code>Figure</code> can be named as <code>Constrain.Figure</code>. For brevity,
the <code>Constrain.</code> qualifier is often omitted in this document.
</p>
<p>
A figure is created by instantiating the class <code>Figure</code> with the identifier
attribute of the canvas in which the figure is to appear, or with the canvas object itself.
In the example above, the canvas is named <code>"fig1"</code>, so this attribute is passed
to the <code>Figure</code> constructor.
</p>
<p>
Typically, the methods of <code>Figure</code> are used to define graphical objects to appear
in the figure, constraints to govern their size and placement, and possibly animation frame
information to specify how the graphical objects and constraints change over time. In
the example above, these methods are invoked implicitly on the new <code>Figure</code> object
because of the <code>with</code> statement; it turns out to be convenient for use with Constrain.
The <code>square</code> and <code>circle</code> methods create graphical objects to be displayed
in the figure. Both of them inherit the figure's default line width of 3; the circle overrides
the fill color to be light blue by calling <code>setFillStyle</code>. The second method call on
the circle introduces constraints to position the cricle at the lower right corner of the square.
Note that graphical objects support cascaded method calls; the result of <code>setFillStyle</code>
is simply the circle itself.
</p>

<h2>Graphical objects</h2>

<p>
Constrain supports a number of useful graphical objects that support a common
API for defining their appearance. The <code>Figure</code> class provides
convenience methods for creating these objects, although they can also be
created by invoking the constructors of the corresponding classes.  Constrain
can be extended with new user-defined graphical objects, using the full power
of HTML canvases to produce desired graphical effects. 
</p>
<p>
Graphical objects are drawn in the order in which they are declared, so objects
created later may cover those created earlier. In this respect, figures are not
fully declarative.
</p>

<h3>Shapes</h3>

<h4>rectangle([fillStyle], [strokeStyle], [lineWidth])</h4>
<p>
A rectangle object (class <code>Rectangle</code>). The default fill style, stroke style,
and line width of the figure may optionally be overridden by providing these parameters.

<pre id="rectangle_ex_code" class=code></pre>
<div id="rectangle_ex">
<canvas id=rectangle_ex_fig></canvas>
<script>
  with (new Constrain.Figure("rectangle_ex_fig")) {
    const grd = ctx.createLinearGradient(0, 0, 100, 100)
    grd.addColorStop(0, "red")
    grd.addColorStop(1, "blue")
    rectangle().setFillStyle(grd)
               .setLineWidth(4)
               .setCornerRadius(10)
  }
</script>
</div>
<script>
    show_example("rectangle_ex_code", "rectangle_ex")
</script>

<h4>square([fillStyle], [strokeStyle], [lineWidth])</h4>
<p>
A square (class <code>Square</code>), which is just a rectangle
constrained to have equal dimensions. The default fill style, stroke style, and
line width of the figure may optionally be overridden by providing these
parameters.

<h4>ellipse([fillStyle], [strokeStyle], [lineWidth])</h4>
<p>
An axis-aligned ellipse (class <code>Ellipse</code>).  The default fill
style, stroke style, and line width of the figure may optionally be overridden
by providing these parameters.

<pre id="ellipse_ex_code" class=code></pre>
<div id="ellipse_ex">
<canvas id=ellipse_ex_fig></canvas>
<script>
  with (new Constrain.Figure("ellipse_ex_fig")) {
    let e = ellipse().setFillStyle("#fde")
    equal(e.width(), times(2, e.height()),
          canvasRect().inset(2).width())
  }
</script>
</div>
<script>
    show_example("ellipse_ex_code", "ellipse_ex")
</script>

<h4>circle([fillStyle], [strokeStyle], [lineWidth])</h4>
<p>
A circle object (class <code>Circle</code>), which is just an ellipse
constrained to have equal dimensions. The default fill style, stroke style, and
line width of the figure may optionally be overridden by providing these
parameters.

<h4>polygon(points, [fillStyle], [strokeStyle], [lineWidth])</h4>
<p>
A closed polygon connecting the given array of points (class <code>Polygon</code>).

<pre id="polygon_ex_code" class=code></pre>
<div id="polygon_ex">
<canvas id=polygon_ex_fig></canvas>
<script>
  with (new Constrain.Figure("polygon_ex_fig")) {
    let p1 = point(), p2 = point(), p3 = point()
    equal(100, distance(p1, p2),
          distance(p2, p3), distance(p1, p3))
    equal(p2.y(), p3.y())
    polygon([p1, p2, p3], "#dfd")
  }
</script>
</div>
<script>
    show_example("polygon_ex_code", "polygon_ex")
</script>

<h3>Lines</h3>

<h4>line([strokeStyle], [lineWidth])</h4>
<p>
Creates a straight line whose appearance can be overridden with optional
parameters (class <code>Line</code>).  Its position is defined by adding constraints on the points
returned by its <code>p1()</code> and <code>p2()</code> methods. It can also be
given arrowheads.
</p>

<h4>horzLine([strokeStyle], [lineWidth])</h4>
<p>
Creates a straight horizontal line (class <code>HorzLine</code>).
</p>

<h4>vertLine([strokeStyle], [lineWidth])</h4>
<p>
Creates a straight vertical line (class <code>VertLine</code>).
</p>

<h4>connector(...objects)</h4>
<p>
Connectors (class <code>Connector</code>) are often the easiest way to draw a line. A connector is a smooth
curve connecting the specified list of objects. Typically, the goal is to
connect the objects at the beginning and end of the list, with the intermediate
objects (often <code>Point</code>s) serving as control points to guide the
shape of the curve. Connectors act like Bezier splines near their endpoints but
like B-splines (which are smoother) in the middle. 
</p>

<pre id="connector_ex_code" class=code></pre>
<div id="connector_ex">
<canvas id=connector_ex_fig></canvas>
<script>
  with (new Constrain.Figure("connector_ex_fig")) {
    let c1 = circle().setW(30).at(point(30, 100)),
        c2 = circle().setW(30).at(c1.toRight(100))
    connector(c1, average(c1, c2).toTop(20), c2)
        .setEndArrow("arrow")
  }
</script>
</div>
<script>
    show_example("connector_ex_code", "connector_ex")
</script>

<h3>Text</h3>

<h4>label(text, [fontSize], [fontName], [fillStyle])</h4>
<p>
Creates a graphical object that is a simple line of text.
</p>

<h4>textFrame(text, [fillStyle])</h4>
<p>
Creates a graphical object that is a box containing text. The text is automatically reformatted
to fit within the box. Note that several other graphical objects, such as rectangles and circles,
support adding text with similar formatting capability.
</p>

<h4>lineLabel(text, position, [offset], [fontSize], [fontName], [fillStyle])</h4>
<p>
Creates a label containing the given text, positioned somewhere along a connector. The
position is a number from 0 to 1, representing how far along the connector the label is placed.
The optional <code>offset</code> parameter specifies how far to the port
side of the connector the label is placed.  A line label is added to a
connector using the connector's <code>addLabel</code> method. (Line labels are not
currently supported for simple lines, although they ought to be.)
</p>
<pre id="linelabel_ex_code" class=code></pre>
<div id="linelabel_ex">
<canvas id=linelabel_ex_fig></canvas>
<script>
  with (new Constrain.Figure("linelabel_ex_fig")) {
    let c1 = square().setW(30).setLineDash([4,4])
                     .at(point(30, 100))
        c2 = square().setW(30).at(c1.toRight(100))
    connector(c1, c2)
        .setStartArrow("bullet")
        .setEndArrow("bullet")
        .addLabel(lineLabel("label", 0.5, 10))
  }
</script>
</div>
<script>
    show_example("linelabel_ex_code", "linelabel_ex")
</script>

<h3>Interactive objects</h3>

<h4>handle(style)</h4>
<p>
A handle (class <code>Handle</code>) is an object that can be moved using the mouse,
affecting any constraints that depend on its position. The following example constrains
distances to dynamically circumscribe a triangle;
you can draw the diamond-shaped handle to change the figure.
</p>

<pre id="handle_ex_code" class=code></pre>
<div id="handle_ex">
<canvas id=handle_ex_fig></canvas>
<script>
  with (new Constrain.Figure("handle_ex_fig")) {
    let c = circle("#def"), h1 = handle(),
        p2 = point(150, 150), p3 = point(50, 150)
    hint(h1.x(), 20); hint(h1.y(), 20)
    polygon([h1, p2, p3])
    equal(distance(c, h1), distance(c, p2),
          distance(c, p3))
    c.setW(times(2, distance(c, h1)))
    geq(minus(p3.y(), h1.y()), 10) // ensure solvable!
  }
</script>
</div>
<script>
    show_example("handle_ex_code", "handle_ex")
</script>


<h4>advanceButton()</h4>
<p>
A button that can be used to advance the current state of the animation.
</p>

<pre id="advance_ex_code" class=code></pre>
<div id="advance_ex">
<canvas id=advance_ex_fig></canvas>
<script>
  with (new Constrain.Figure("advance_ex_fig")) {
    const f0 = addFrame(), f1 = addFrame(),
          f2 = addFrame(), f3 = addFrame()
    setRepeat(true); setFadeColor("#fed")
    setFillStyle("yellow")
    group(drawAfter(f1, square().addText("1")),
          drawAfter(f2, square().addText("2")),
          drawAfter(f3, square().addText("3")))
      .setH(30)
      .align("abut", "top bottom")
    align("right", "bottom",
          advanceButton(), canvasRect().inset(2))
  }
</script>
</div>
<script>
    show_example("advance_ex_code", "advance_ex")
</script>

<h3>Unrendered objects</h3>
<p>
Some figure elements act like graphical objects in most respects but do not result in 
any rendering. These objects are useful for positioning other objects.
</p>

<h4>point()</h4>
<p>
Creates a point (class <code>Point</code>) at an unspecified location. Its
location is solved for.
</p>

<h4>point(x, y)</h4>
<p>
Creates a point (class <code>Point</code>) at the location (x,y). This is
equivalent to <code>point().at(x,y)
</p>

<h4>box()</h4>
<p>
A box (class <code>Box</code>) is an axis-aligned rectangle that has no
rendering. In other respects it acts like a graphical object; for example, it
has a width and height.
</p>

<h4>hspace(w)</h4>
<p>
Horizontal space. It has width <code>w</code> but zero height.
</p>

<h4>vspace(h)</h4>
<p>
Vertical space. It has height <code>h</code> but zero width.
</p>

<h4>DOMElement(id)</h4>
<p>
A box with position and the size of the DOM element with the specified id
attribute (class <code>DOMElementBox</code>).  This feature helps overlay
graphics onto regular web page content.
</p>

<h4>canvasRect()</h4>
<p>
A box exactly filling the canvas the figure is drawn in, which is useful for
positioning objects relative to the canvas.
</p>

<h4>group(...objects)</h4>
<p>
A box containing a set of objects. The box is just large enough to surround all the objects.
</p>

<h3>User-defined graphical objects</h3>
<p>
The class <code>UserDefined</code> provides a template for building new graphical objects.
By default, a user-defined object is drawn as a plain gray square.
It is the responsibility of the user to define a subclass of <code>UserDefined</code>, in
which the following method is overridden:

<h4>draw(context, frame, time, x0, y0, x1, y1)</h4>
<p>
Draw a user-defined object in the graphical context <code>context</code>. The current
animation frame is <code>frame</code> and the time (0â€“1) within that frame is <code>time</code>.
The parameters <code>x0</code>, <code>y0</code>, <code>x1</code>, <code>y1</code> define the
box that nominally contains the object.
</p>

<h2>Figure control</h2>
<p>
Figure objects offer some methods for controlling the figure as a whole:

<h4>start()</h4>

<p>Requests the figure to start rendering when it is ready.
Figures do not automatically appear; for example, this document
ends with a loop over the list of all figures (<code>Constrain.Figures</code>),
telling each one to start:
</p>
<pre class=code style="float:none" id="startup_code_ex"></pre>

<h4>stop()</h4>

<p>Clears the figure and moves it back to an unready status.</p>

<h4>destroy()</h4>

<p>Destroys the figure and removes it from the list of figures (<code>Constrain.Figures</code>).</p>

<h3>Other operations</h3>
<h4>Constrain.fullWindowCanvas(canvas)</h4>
<p>
Makes the specified canvas automatically resize to fill the window.
</p>

<h4>Constrain.autoResize()</h4>
<p>
This function causes figures to automatically resize to their containing canvases.
</p>


<h3>Default styles</h3>

<p>
Graphical objects can set their own style, but if no style is specified, the style is inherited
from the figure. The following figure methods support defining the default styles, taking the
same arguments as the corresponding methods on graphical objects.
</p>

<h4>setFillStyle(style)
    setStrokeStyle(style)<br/>
    setLineWidth(w)<br/>
    setFontSize(s)<br/>
    setFontName(n)</code></h4>

<h2>Constraints</h2>

<p>
The appearance of a figure is governed by a set of constraints. Some graphical objects
automatically add their own constraints to the set. Additional constraints can be added
by methods on the figure object.
</p>

<h4>align(horizontal, vertical, ...objs)</h4>
<p>
Aligns the objects in the list <code>objs</code> according to the alignment specification
given by the strings <code>horizontal</code> and <code>vertical</code>, and returns the
associated array of constraints added to achieve this alignment. Objects may be
passed either as a single array of objects or as a variable-length list of arguments.
The horizontal alignment specification can be any of the following:
</p>
<ul>
<li><code>"none"</code>: No horizontal alignment
<li><code>"left"</code>: Align left sides
<li><code>"right"</code>: Align right sides
<li><code>"center"</code>: Align horizontal centers
<li><code>"left right"</code>: Align both left and right sides, forcing the objects to have the
                same width.
<li><code>"abut"</code>: Make objects abut each other directly, left-to-right. Space may be inserted
            between the objects using the method <code>hspace()</code>.
<li><code>"distribute"</code>: Equalize the horizontal separation between the objects in the list.
</ul>
<p>
The vertical alignment specification is the same as the horizontal specification, except
that <code>top</code> and <code>bottom</code> replace <code>left</code> and <code>right</code>.
</p>

<h4>equal(...e)</h4>
<p>
Adds and returns a constraint that the expressions in the list <code>e</code> are all equal to each other.
</p>

<h4>geq(...e)</h4>
<p>
Adds and returns a constraint that each expression in the list <code>e</code> is greater than or equal to
those later in the list.
</p>

<h4>nearZero(e)</h4>
<p>Adds and returns a constraint that expression <code>e</code> is as close to zero as possible.</p>

<h4>positive(e)</h4>
<p>
Adds and returns a constraint that the expression <code>e</code> is greater than or equal to zero.
</p>

<h4>leq(...e)</h4>
<p>
Adds and returns a constraint that each expression in the list <code>e</code> is less than or equal to the next.
</p>

<h4>pin(...o)</h4>
<p>
Adds and returns a constraint that all the objects in the list <code>o</code> are located at the same position.
</p>

<h4>collinear(p0, p1, p2)</h4>
<p>
Adds and returns a constraint that the points <code>p0</code>, <code>p1</code>, <code>p2</code> all lie in
a straight line.
</p>

<h4>constraintGroup(...constraints)</h4>
<p>Adds and returns a constraint that enforces all of the supplied constraints.</p>

<h4>keepInside(obj1, obj2)</h4>
<p>
Constrain object <code>obj1</code> to remain inside the bounding box of <code>obj2</code>.
</p>

<h4>sameSize(obj1, obj2)</h4>
<p>
Constrain objects <code>obj1</code> and <code>obj2</code> to have the same width and height.
</p>

<h3>Costs</h3>
<p>
In general, the constraint solver cannot solve every constraint exactly. It works by trying to
minimize a total cost over all constraints. Every constraint has an associated cost multiplier
that is equal to 1 by default. Usually this does not need to be changed, but it can be useful
to change the cost of some constraints to make them softer or harder constraints relative to
other constraints.
<h4>changeCost(c)</h4>
<p>
This method can be invoked on <code>Constraint</code> objects to multiply the current cost by
the factor <code>c</code>
</p>
<h3>Expressions</h3>
<p>
Some constraints are built out of expressions. The following expressions are
supported by the constraint solver. Expressions may have a either a scalar
value (a number) or an array value. For example, as an expression, a point
evaluates to a two-element array, and any graphical objects evaluates similarly
to its center position.  Many operations can be performed either on scalars or
arrays. The function <code>Constrain.evaluate</code> may be used to obtain the
current value of an expression, although usually this is not needed.

<h4>plus(a, b)</h4>
<p>The sum of <code>a</code> and <code>b</code>, which may be scalars or arrays.
</p>

<h4>minus(a, b)</h4>
<p>The difference of <code>a</code> and <code>b</code>, which may be scalars or arrays.
</p>

<h4>times(a, b)</h4>
<p>The product of <code>a</code> and <code>b</code>, at least one of which must be a
scalar.
</p>

<h4>divide(a, b)</h4>
<p>Dividing <code>a</code> by <code>b</code>. The divisor must be a scalar.
</p>

<h4>abs(a)</h4>
<p>The absolute value of <code>a</code>.</p>

<h4>sqrt(a)</h4>
<p>The square root of <code>a</code>.</p>

<h4>sqr(a)</h4>
<p>The square of <code>a</code>.</p>

<h4>average(a, b)</h4>
<p>The average of the arguments, which may be arrays of the same length.</p>

<h4>distance(p1, p2)</h4>
<p>The Euclidean distance between points <code>p1</code> and <code>p2</code>.

<h4>max(a, b, ...)</h4>
<p>The maximum of the arguments, which must all be scalars.</p>
</p>

<h4>min(a, b, ...)</h4>
<p>The minimum of the arguments, which must all be scalars.</p>
</p>

<h4>linear(frame, a, b)</h4>
<p>An expression (class <code>Linear</code>) whose value is the value of expression <code>a</code> before the
specified frame, and the value of <code>b</code> after that frame. During the
frame, it linearly interpolates over time between <code>a</code> and
<code>b</code>.
</p>

<h4>smooth(frame, a, b)</h4>
<p>An expression (class <code>Smooth</code>) whose value is the value of expression <code>a</code> before the
specified frame, and the value of <code>b</code> after that frame. During the
frame, ts value interpolates over time between <code>a</code> and
<code>b</code>, using a cubic spline so that the rate of change at the
endpoints is zero.
</p>

<pre class=code id="smooth_code_ex"></pre>
<div id="smooth_ex" style="margin: 1em">
<canvas id=smooth_ex_fig></canvas>
<script>
  with (new Constrain.Figure("smooth_ex_fig")) {
    let frame1 = addFrame(),
        frame2 = addFrame().setLength(1000)
    square().setW(20).setLineWidth(4)
      .at(smooth(frame2,
        canvasRect().toLeft(-20),
        canvasRect().toRight(-20)))
    align("right", "bottom",
          advanceButton(), canvasRect().inset(2))
  }
</script>
</div>
<script>
  show_example("smooth_code_ex", "smooth_ex")
</script>



<h4>variable(name)</h4>
<p>
Creates and returns a fresh variable that can be solved for. Its name is based on the <code>name</code>
parameter. Normally this method does not need to be used directly.
</p>

<h4>hint(e, v)</h4>
<p>
Add a hint to the solver that the value <code>v</code>, which must be a number or array of
numbers, is a good initial guess for the solved value of the expression <code>e</code>.
Usually such hints are not necessary; the main use is in situations where there are multiple
solutions and you want to bias the solver toward one of them. It returns the expression <code>e</code>.
</p>

<h3>Other expressions</h3>

<h4>new Global(f)</h4>
<p>
The class <code>Global</code> represents an expression whose value may change but which is
not affected by any variables that are solved for. Its value is provided by a function <code>f</code>
passed to the constructor. It is useful for interfacing Constrain diagrams with external data
sources.
</p>

<h4>new DebugExpr(e)</h4>
<p>
Wrapping an expression in a <code>DebugExpr</code> object causes the value of
that expression to be logged to the console whenever it is evaluated or
differentiated.  The class <code>Global</code> represents an expression whose
value may change but which is not affected by any variables that are solved
for. Its value is provided by a function <code>f</code> passed to the
constructor. It is useful for interfacing Constrain diagrams with external
data sources.
</p>
<h2>Positions</h2>
<p>
Graphical objects provide methods that return expressions for scalars and
points relating to their position in the figure.
</p>

<div id="positions_ex" style="float: right; margin: 1em">
<canvas id=positions_ex_fig style="width: 300px; height: 300px"></canvas>
<script>
  with (new Constrain.Figure("positions_ex_fig")) {
    function dot(p) {
        return circle().setFillStyle("#00c").setStrokeStyle(null).setW(10).at(p)
    }
    function lb(n, p) {
      return label(n).setFillStyle("#00c").setFontName("Menlo").setFontSize(10).at(p)
    }
    let c = circle().setLineWidth(3).setFillStyle("#def"),
        s = box(),
        h0 = horzLine().setLineDash([8,8]).setLineWidth(1),
        h1 = horzLine().setLineDash([8,8]).setLineWidth(1)
        hc = horzLine().setLineDash([8,8]).setLineWidth(1)
        v0 = vertLine().setLineDash([8,8]).setLineWidth(1),
        vc = vertLine().setLineDash([8,8]).setLineWidth(1),
        v1 = vertLine().setLineDash([8,8]).setLineWidth(1)
    align("center", "center", c, canvasRect())
    align("left right", "none", h0, h1, hc,canvasRect())
    align("none", "top bottom", v0, v1, vc, canvasRect())
    align("left right", "top bottom", c, s)
    align("center", "none", vc, c)
    align("none", "center", hc, c)
    align("none", "top", h0, c)
    align("none", "bottom", h1, c)
    align("left", "none", v0, c)
    align("right", "none", v1, c)
    equal(c.width(), times(0.7, canvasRect().width()))
    dot(s.ul());    dot(s.uc());      dot(s.ur())
    dot(s.cl());    dot(s.center());  dot(s.cr())
    dot(s.ll());    dot(s.lc());      dot(s.lr())
    setFillStyle("#00c")
    let off = 15
    lb("ul", s.ul().toLeft(off).toTop(off))
    lb("cl", s.cl().toLeft(off).toTop(off))
    lb("ll", s.ll().toLeft(off).toBottom(off))
    lb("ur", s.ur().toRight(off).toTop(off))
    lb("cr", s.cr().toRight(off).toTop(off))
    lb("lr", s.lr().toRight(off).toBottom(off))
    lb("uc", s.uc().toTop(off).toLeft(off))
    lb("lc", s.lc().toBottom(off).toLeft(off))
    lb("x", point(plus(10, c.x()), 10))
    lb("x1", point(plus(10, c.x1()), 10))
    lb("x0", point(plus(10, c.x0()), 10))
    lb("y", point(10, plus(10, c.y())))
    lb("y1", point(10, plus(10, c.y1())))
    lb("y0", point(10, plus(10, c.y0())))
    lb("center", c.center().toRight(25).toBottom(10))
    let wl = horzLine().setEndArrow("arrow").setStartArrow("arrow").setStrokeStyle("#00c")
    align("left right", "abut", c, vspace(30), wl)
    lb("w", wl.toBottom(10))
    let hl = vertLine().setEndArrow("arrow").setStartArrow("arrow").setStrokeStyle("#00c")
    align("abut", "top", c, hspace(30), hl)
    equal(hl.y1(), c.y1())
    lb("h", hl.toRight(10))
  }
</script>
</div>

<h4>x()</h4>
<p>
The horizontal position of the center of the object, as a canvas coordinate.
</p>
<h4>y()</h4>
<p>
The vertical position of the center of the object, as a canvas coordinate. Recall
that y coordinates start from zero at the top of the canvas and increase downward.
</p>
<h4>x0()</h4>
<p>
The horizontal position of the left edge.
</p>
<h4>x1()</h4>
<p>
The horizontal position of the right edge.
</p>
<h4>y0()</h4>
<p>
The vertical position of the top edge.
</p>
<h4>y1()</h4>
<p>
The vertical position of the bottom edge.
</p>
<h4>width(), w()</h4>
<p>
The width of the object.
</p>
<h4>height(), h()</h4>
<p>
The height of the object.
</p>
<h4>center()</h4>
<p>
The center point of the object.
</p>

<h4>ul(), ll(), ur(), lr()</h4>
<p>
These four methods each return a point corresponding to the one of the
four corners of the object: upper left, lower left, upper right, and lower right.
</p>
<h4>uc(), lc(), cr(), cl()</h4>
<p>
These methods each return a point that is the center of one of the edges of the
bounding box of the object.
</p>
<h4>toTop(d), toBottom(d), toRight(d), toLeft(d)</h4>
<p> These methods can be used to nudge the position of a point or object in the
specified direction by distance <code>d</code>, returning the resulting point.
When applied to a graphical object, the starting position is respectively, the
result of <code>uc()</code>, <code>lc()</code>, <code>cr()</code>, or
<code>cl()</code>. It is possible for the nudge distance to be negative, which is useful
for nudging a point into the interior of a graphical object.
</p>

<h2>Animation</h2>

<p>
A figure has one or more <i>frames</i> that can differ in what
objects and constraints are operative during each frame.

<h3>Figure methods for animation</h3>

<p>By default, a figure has a single frame, but new frames can be added, creating
an animation that can be controlled using an <code>AdvanceButton</code> or by other
programmatic means.</p>

<h4>addFrame(...names)</h4>

<p>Adds one or more frames to the figure. Names may optionally be supplied for the frames.</p>

<h4>reset()</h4>
<p>Resets this figure back to its first frame.</p>

<h4>advance()</h4>
<p>Advances this figure to the next frame, if any. Returns true if
there is a next frame to go to.</p>

<h4>rewind()</h4>
<p>Rewinds this figure to the previous frame, if any.
Returns true if there is a previous frame to go to.</p>

<h4>setRepeat(b)</h4>
<p>Set whether the figure resets to the first frame when it
advances past the last frame.
</p>

<h4>setFadeColor(color)</h4>
<p>
For repeating figures, there is a period in which the figure
fades out to a color (by default, white). If the fade color is
set to the background color of the page, the fade effect will
be effective.
</p>

<h4>setAnimatedSolving(b)</h4>
<p>
The constraint solver does not show its solving process by default.
If this method is called with <code>true</code>, the steps the solver takes
are shown as an animation. This can be useful for visualization or debugging.
</p>

<h3>Animating graphical objects</h3>

<p>
By default, graphical objects and constraints exist for the entire duration of a figure.
However, objects and constraints can be wrapped in frame filters that make them exist
or be visible only some of the time. Convenience methods in <code>Figure</code> make these
easy to use.
</p>

<h4>drawAfter(frame, ...objs)</h4>
<p>
Draw objects <code>objs</code> only starting from the specified frame.
However, the objects still exist in the figure.
</p>

<h4>drawBefore(frame, ...objs)</h4>
<p>
Draw objects <code>objs</code> only before the specified frame.
However, the objects still exist in the figure.
</p>

<h4>drawBetween(frame1, frame2, ...objs)</h4>
<p>
Draw objects <code>objs</code> only starting from frame <code>frame1</code> and
before frame <code>frame2</code>. However, the objects still exist in the
figure.
</p>

<h4>after(frame, ...objs_constraints)</h4>
<p>
Objects or constraints <code>objs_constraints</code> are only present in the figure
starting from frame <code>frame1</code>. Note that introducing new constraints
can cause objects to jump discontinuously at frame boundaries, so the method
<code>drawAfter</code> may be a better choice.
</p>

<h4>before(frame, ...objs_constraints)</h4>
<p>
Objects or constraints <code>objs_constraints</code> are only present in the figure
before frame <code>frame1</code>.
</p>

<h4>between(frame1, frame2, ...objs_constraints)</h4>
<p>
Objects and constraints <code>objs_constraints</code> are only present in the figure
after frame <code>frame1</code> and before frame <code>frame2</code>.
</p>

<h3>Frame methods</h3>
<p>
Frame objects returned by <code>addFrame()</code> support methods for controlling
animations.
</p>

<h4>setLength(ms)</h4>
<p>
By default, a frame has zero duration; it is simply rendered once. By giving the frame
a duration in milliseconds, the frame renders repeatedly for the given duration, with
the value of certain expressions (e.g., <code>Linear</code> and <code>Smooth</code>)
varying continuously over the duration.
</p>

<h4>setAutoAdvance(b)</h4>
<p>
If invoked on a frame with <code>true</code>, the frame automatically advances
to the following frame once its duration is over.
</p>

<h2>Graphs</h2>
<p>
Constrain also includes support for automatic graph layout. The class <code>Graph</code>
represents a graph consisting of nodes and edges. It has various methods for building
and controlling the automatic layout of the graph.
</p>

<h3>Graph methods</h3>

<h4>addNode(obj)</h4>
<p>
Add the graphical object <code>obj</code> as a node in the graph.
</p>

<h4>edge(obj1, obj2)</h4>
<p>
Add an undirected edge from graph node <code>obj1</code> to graph node <code>obj2</code>.
</p>

<h4>dedge(obj1, obj2)</h4>
<p>
Add a directed edge from graph node <code>obj1</code> to graph node <code>obj2</code>.
</p>

<h3>Graph properties</h3>
<p>
  The layout of a graph is controlled by various graph properties whose default values can be overridden.
</p>
<h4>sparsity</h4>
<p>
This parameter controls how widely separated graph nodes are.
</p>
<h4>cost</h4>
<p>
Graphs are laid out using soft constraints whose importance is scaled relative to ordinary constraints
by the <code>cost</code> property of the graph.
</p>
<h4>gravity</h4>
<p>
Nodes in a directed graph experience a force like gravity that tends to push edges to align with it.
The strength of this force is controlled by the property <code>gravity</code>.
</p>
<h4>repulsion</h4>
<p>
Nodes in the graph exert a repulsive force on nearby nodes to discourage overlap. The
property <code>repulsion</code> controls the strength of the repulsive force.
</p>
<h4>branchSpread</h4>
<p>
When a node is connected to multiple other nodes, a torque is introduced on the edges to
those nodes, to try to equalize the angles between the edges. The strength of the torque
is controlled by the <code>branchSpread</code> property.
</p>

</div>

<div id="startup_code">
<script>
  Constrain.Figures.forEach(f => f.start())
</script>
</div>
<script>
  show_example("startup_code_ex", "startup_code")
</script>

</body>
</html>
