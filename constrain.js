"use strict"

// Constrain: A package for creating animated figures in JavaScript canvases,
// similar to the sort of animated figure you would put into a slide
// presentation, or for web-based course notes.
// 
// Author: Andrew Myers, 2019-2021

var Constrain = function() {

// There is a set of Figure objects recorded in the array Figures. Each one
// is attached to a separate canvas.
// 
const Figures = []

// Various switches and constants control the default appearance of figures.

const USE_BACKPROPAGATION = true,
      CACHE_ALL_EVALUATIONS = false,
      CHECK_NAN = true,
      COMPARE_GRADIENTS = false,
      TINY = 1e-17

let DEBUG = false

const NUMBER = "number", FUNCTION = "function", OBJECT_STR = "object"

const Figure_defaults = {
    ARROW_SIZE : 12,
    FONT_SIZE : 12,
    LINEWIDTH : 1,
    TRIANGLE_SIZE : 10,
    FRAMERATE : 60,
    FONT_NAME : "sans-serif",
    FONT_STYLE : "",
    LINE_SPACING : 1.3,
    SUPERSCRIPT_OFFSET : 0.44,
    SUBSCRIPT_OFFSET : -0.16,
    SCRIPTSIZE : 0.80,
    LARGE_SPAN : 10000.0,
    HYPHEN_COST : 100000,
    CONNECTION_STYLE : 'magnet'
}

// There is a set of Variables that can be adjusted to minimize an objective
// function generated by summing costs from various constraints. Depending on
// which frame a figure is on, different variables are active and solved for.
//
// Expressions can be built out of Variables. Constraints are built using expressions.
// They have a cost that is supposed to be as small as possible (zero, if the constraint
// is fully satisfiable). The solver tries to minimize the total cost of all constraints.
//
// Associated with each figure is a set of GraphicalObjects that know how to
// render themselves based on associated Variables.
//
// When new graphical objects are created, their style is set to their figure's
// style by default, but can be changed later.

// A Figure is attached to a canvas and knows how to render itself. It has a
// set of associated Frames which can be stepped through. GraphicalObjects and
// Constraints can be attached to a figure.
// 
class Figure {
    // Create a figure appearing in a canvas.  'canvas' should be either the
    // canvas HTML element or, for convenience, its id attribute as a string
    constructor(canvas) {
        this.figure = this
        if (typeof canvas == OBJECT_STR && canvas.constructor == HTMLCanvasElement) {
            this.canvas = canvas
        } else if (typeof canvas == "string") {
            const c = document.getElementById(canvas)
            if (c) {
                this.canvas = canvas = c
                this.name = c.id
            } else {
                console.error('Could not find any canvas with id "' + canvas + '"')
            }
        } else {
            console.error("new Figure() expects a canvas or a canvas id")
            return
        }
        this.ctx = canvas.getContext("2d")
        this.is_ready = true   // whether figure content is marked as ready for rendering
        this.is_started = false // whether a request for rendering has occurred
        this.setupListeners()
        this.initObjects()
        this.scale = window.devicePixelRatio || 1; // canvas units per HTML "pixel"
        this.time = 0
        this.currentFrame = undefined // current frame object
        this.frameRate = Figure_defaults.FRAMERATE
        this.Frames = []
        this.wrapFrames = false // does advancing from last frame go back to first
        this.frameIndex = []
    // default styles
        this.setFillStyle("white")
        this.setStrokeStyle("black")
        this.setTextStyle("black")
        this.setLineWidth(Figure_defaults.LINEWIDTH)
        this.font = new Font()
        this.lineSpacing = Figure_defaults.LINE_SPACING
        this.arrowSize = Figure_defaults.ARROW_SIZE
        this.connectionStyle = Figure_defaults.CONNECTION_STYLE
        this.repeat = false
        this.animatedSolving = false
        this.solverCallbacks = []
        this.fadeColor = 'white'
        Figures.push(this)
        if (canvas.style.padding && canvas.style.padding != "0px")
            console.error("Canvas input will not work correctly with padding")
    }
    setupCanvas() {
        const canvas = this.canvas, br = canvas.getBoundingClientRect(),
              _width = br.width, _height = br.height
        this.width = _width
        this.height = _height
        this.canvas.width = _width * this.scale
        this.canvas.height = _height * this.scale
        this.ctx.setTransform(this.scale, 0, 0, this.scale, 0, 0)
    }
    toString() {
        return "Figure"
    }
    setupListeners() {
        const canvas = this.canvas
        this.canvas.addEventListener('mousedown', e => {
            const x = e.offsetX, y = e.offsetY
            // alternatively: could use clientX/clientY with getBoundingClientRect
            this.interactives.forEach(i => {
                if (!i.mousedown(x, y, e)) return false
            })
            e.preventDefault()
            e.stopPropagation()
            return false
        })
        this.canvas.addEventListener('mouseup', e => {
            const x = e.offsetX, y = e.offsetY
            this.interactives.forEach(i => {
                if (!i.mouseup(e)) return false
            })
            e.preventDefault()
            e.stopPropagation()
            return false
        })
        this.canvas.addEventListener('mousemove', e => {
            if (!this.focused) return false
            const x = e.offsetX, y = e.offsetY
            return this.focused.mousemove(x, y, e)
            e.preventDefault()
            e.stopPropagation()
            return false
        })
        this.canvas.addEventListener('dblclick', e => {
            e.preventDefault()
            e.stopPropagation()
            return false
        })
        this.canvas.addEventListener('click', e => {
            e.preventDefault()
            e.stopPropagation() 
            return false
        })
    }
    initObjects() {
        this.GraphicalObjects = []
        this.Constraints = []
        this.Graphs = []
        this.Variables = []
        this.numVariables = 0
        this.interactives = []
        this.events = []
        this.focused = null
        this.renderNeeded = false
    }
    initialValuation() {
        if (this.Variables.length != this.numVariables) {
            alert("oops " + this.numVariables + " " + this.Variables.length)
            console.error("oops")
        }
        const result = new Array(this.activeVariables.length)
        for (let i = 0; i < this.activeVariables.length; i++) {
            const v = this.activeVariables[i]
            if (v.currentValue != null) result[i] = v.currentValue
            else if (v.hint != null) result[i] = v.hint
            else result[i] = 100
        }
        return result
    }
    evaluate(e, valuation, doGrad) {
        if (!valuation) valuation = this.currentValuation
        return evaluate(e, valuation, doGrad)
    }
    numberVariables() {
        let i = 0, a = [], frame = this.currentFrame
        this.Variables.forEach(v => v.removeIndex())
        function activate(v) {
            if (v.index !== undefined) return
            if (v.constructor != Variable)
                console.error("not a variable")
            v.setIndex(i)
            a.push(v)
            i++
        }
        this.GraphicalObjects.forEach(g => {
            if (g.active()) {
                g.variables().forEach(activate)
            }
        })
        this.Constraints.forEach(c => {
            if (c.active())
                c.variables().forEach(activate)
        })
        this.activeVariables = a
    }
    resetValuation() {
        this.numberVariables()
        this.currentValuation = this.initialValuation()
    }
    // Add one or more constraints that should be satisfied
    // If an array is passed as an argument, each element is added
    // as a constraint.
    // A constraint should return a nonnegative cost
    // Normally, constraints call this method themselves
    addConstraints(...constraints) {
        constraints.flat().forEach(c => {
            if (!this.Constraints.includes(c)) this.Constraints.push(c)
        })
    }
    removeConstraints(...constraints) {
        constraints = constraints.flat()
        this.Constraints = this.Constraints.filter(c => !constraints.includes(c))
    }

    totalCost(valuation) {
        return this.costGrad(valuation, false)
    }

    // compute the gradient of the output cost at value 'valuation' with
    // respect to all active expressions, including variables, using
    // backpropagation. Two different backprop evaluations cannot happen
    // at the same time, because partial results are stored in the expression
    // objects themselves, in their bpDiff field.
    //
    // Requires that all variables have been numbered appropriately.
    bpGrad(valuation, task) {
        const n = valuation.length,
              val = this.totalCost(valuation) // initalize node values
        task.run(valuation)
        const grad = new Array(n)
        for (let i = 0; i < n; i++) {
            const v = this.activeVariables[i]
            if (v.bpTask !== task) {
                // console.log("Variable did not have its gradient computed: " + v)
                grad[i] = 0
            } else {
                grad[i] = v.bpDiff
            }
        }
        if (COMPARE_GRADIENTS) {
            let [cgVal, cgGrad] = this.costGrad(valuation, true)
            for (let i = 0; i < valuation.length; i++) {
                if (exceedsError(cgVal, val)) {
                    console.error("Difference between computed values exceeds error")
                }
                if (exceedsError(cgGrad[i], grad[i])) {
                    console.error("Difference between computed gradients exceeds error")
                }
            }
        }
        return [val, grad]
    }

    isActiveConstraint(con) {
        if (!con.active()) return false
        if (con.parent !== undefined) return this.isActiveConstraint(con.parent)
        return true
    }

    setupBackPropagation(task) {
        this.Constraints.forEach(con => {
            if (!this.isActiveConstraint(con)) return
            con.addToTask(task)
        })
    }

    // Compute the total cost of the constraints, and the gradient of
    // the cost wrt the currently active variables. This is done by
    // symbolic differentiation.
    costGrad(valuation, doGrad) {
        let n = valuation.length, cost = 0, dcost = new Array(n).fill(0)
        this.Constraints.forEach(con => {
            if (!this.isActiveConstraint(con)) return
            const result = con.getCost(valuation, doGrad)
            let c, dc
            if (doGrad) {
                if (CHECK_NAN && checkNaNResult(result)) return
                [c, dc] = result
                dcost = numeric.add(dcost, dc)
            } else {
                c = result
            }
            cost += c
        })
        if (!doGrad) {
            return cost
        } else {
            return [cost, dcost]
        }
    }
    updateValuation(tol) {
        this.numberVariables()
        if (this.currentValuation === undefined || this.currentValuation.length < this.activeVariables.length)
            this.resetValuation()
        if (this.currentValuation.length > this.activeVariables.length)
            this.currentValuation = this.currentValuation.slice(0, this.activeVariables.length)
        return this.solveConstraints(this.currentValuation, tol)
    }
    // Register a callback to be invoked at every solver step
    registerCallback(cb) {
        for (let i = 0; i < this.solverCallbacks.length; i++) {
            if (this.solverCallbacks[i] == cb) return
        }
        this.solverCallbacks.push(cb)
    }
    // Unregister a callback. Either the callback object itself or
    // its name may be supplied as an argument.
    unregisterCallback(name) {
        for (let i = 0; i < this.solverCallbacks.length; i++) {
            if (this.solverCallbacks[i].name == name ||
                this.solverCallbacks[i] === name) {
                this.solverCallbacks = this.solverCallbacks.slice(0, i)
                                           .concat(this.solverCallbacks.slice(i+1))
            }
        }
    }
    solveConstraints(valuation, tol) {
        let doGrad = true, fig = this
        if (valuation === undefined) {
            console.error("Need initial valuation")
            return
        }
        const task = USE_BACKPROPAGATION ? new BackPropagation(this.activeVariables) : undefined
        if (USE_BACKPROPAGATION) {
            this.setupBackPropagation(task)
        }
        let result, callback, maxit = 1000
        if (this.solverCallbacks.length > 0) {
            callback = (it, x0, f0, g0, H1) => {
                for (let i = 0; i < this.solverCallbacks.length; i++) {
                    if  (this.solverCallbacks[i].call(it, x0, f0, g0, H1)) return true
                }
                return false
            }
        }
        if (this.invHessian && this.invHessian.length != valuation.length) this.invHessian = undefined
        const uncmin_options = {Hinv: this.invHessian,
                                stepSize: UNCMIN_STEPSIZE,
                                overshoot: UNCMIN_OVERSHOOT}
        if (doGrad) { if (USE_BACKPROPAGATION) {
                result = uncmin((v,d) => { return d ? fig.bpGrad(v, task) : fig.totalCost(v) },
                                valuation, tol, maxit, callback, uncmin_options)
            } else {
                result = uncmin((v,d) => fig.costGrad(v,d), valuation, tol, maxit, callback, uncmin_options)
            }
        } else {
            result = numeric.uncmin(this.totalCost, valuation, tol, undefined, maxit, uncmin_options)
        }
        // console.log(result)
        this.invHessian = result.invHessian
        // if (result.message != CALLBACK_RETURNED_TRUE) console.log(result.message)
        return [result.solution, result.message != CALLBACK_RETURNED_TRUE]
    }

// Rendering
    renderIfDirty(animating) {
        if (this.currentFrame === undefined) {
            console.log("current frame not defined yet, skipping render")
            return
        }
        if (this.renderNeeded) {
            this.render(animating)
            this.renderNeeded = false
        }
    }
    // Render this figure for current time t in [0,1] (fraction of completion of current frame)
    // Parameter animating is whether this is just an intermediate animation frame
    render(animating) {
        if (undefined === this.animationTime) {
            console.log("Animation time not set")
            this.animationTime = 0
        }
        this.setupCanvas()
        this.ctx.setTransform(this.scale, 0, 0, this.scale, 0, 0)
        this.ctx.clearRect(0, 0, this.width, this.height)
        this.Graphs.forEach(g => g.setupHints())
        let solved
        [this.currentValuation, solved] = this.updateValuation(animating ? 0.05 : 0.01)
        this.renderFromValuation()
        if (!solved) {
            setTimeout(() => this.render(animating), 10) // XXX might be nice to use Promise
        }
    }

    // Render the figure using the current valuation, whatever it is.
    renderFromValuation() {
        this.GraphicalObjects.forEach(g => {
            if (g.parent === undefined && g.renderIfVisible)
              g.renderIfVisible()
        })
    }

// Frame management

    // create one or more new frames, returning either the
    // single new frame or an array of the new frames.
    addFrame(...names) {
        if (names.length > 1) {
            return names.flat().map(n => new Frame(this, n))
        } else {
            return new Frame(this, names)
        }
    }

    getFrame(i) {
        return this.Frames[i]
    }

    // Mark this figure as being ready for rendering.
    // Create an initial frame if no frames have been created yet.
    ready() {
        if (this.Frames.length == 0)
            this.Frames[0] = new Frame(this, "default")
        this.is_ready = true
        if (this.is_started) this.start()
    }

    // Request that this figure start rendering. If the figure
    // is not ready to render, it will just set the is_started
    // flag.
    start() {
        // console.log("starting figure")
        this.is_started = true
        if (!this.is_ready) {
            console.log("Figure is not ready to render yet.")
            return
        }
        if (this.Frames.length == 0)
            this.Frames[0] = new Frame(this, "default")
        this.currentFrame = this.Frames[0]
        if (document.readyState == "complete") {
            console.log("Document is ready, starting first frame")
            this.startCurrentFrame()
        } else {
            console.log("Document is not ready, starting listener")
            window.addEventListener('load', () => {
                console.log("Document loaded, starting frame")
                this.startCurrentFrame()
            })
        }
    }
    // Clear this figure and move it back to unready status
    stop() {
        if (this.is_started) {
            this.ctx.clearRect(0, 0, this.width, this.height)
            this.is_started = false
            this.is_ready = false
        }
    }
    // Stop this figure and remove it from the list of figures
    destroy() {
        if (this.is_started) this.stop()
        let f = Figures.pop()
        for (let i = 0; i < Figures.length; i++) {
            if (Figures[i] === this) Figures[i] = f
        }
    }

    // Reset this figure back to the first frame
    reset() {
        this.currentFrame = this.Frames[0]
        this.render(false)
    }

// return the next frame or null if we are at the end already
    nextFrame() {
        if (this.currentFrame === undefined) {
            return this.Frames[0]
        }
        for (let i = 0; i < this.Frames.length; i++) {
            if (this.Frames[i] == this.currentFrame &&
                i + 1 < this.Frames.length) {
                return this.Frames[i+1]
            }
        }
        return null
    }

    prevFrame() {
        if (this.currentFrame === undefined) return null
        for (let i = 0; i < this.Frames.length; i++) {
            if (this.Frames[i] == this.currentFrame && i > 0)
                return this.Frames[i-1]
        }
        return null
    }

    // Advance to the next frame, if any.
    // Return true if there is a next frame to go to.
    advance() {
        if (!this.is_ready) {
            console.log("Cannot advance unready figure")
            return
        }
        const f = this.nextFrame()
        if (DEBUG) console.log("Advancing to frame " + f.name)
        if (f) {
            this.currentFrame = f
            this.startCurrentFrame()
            return true
        } else {
            this.complete()
            if (this.repeat) {
                this.animate(1000, 80,
                  () => {
                    const col = this.fadeColor || 'white'
                    this.ctx.fillStyle = col
                    this.ctx.globalAlpha = 0.3
                    this.ctx.fillRect(0, 0, this.width, this.height)
                  },
                  () => {
                    this.ctx.globalAlpha = 1
                    this.reset()
                    this.render(false)
                  })
            }
            return false
        }
    }

    // Rewind to the previous frame, if any.
    // Return true if there is a previous frame to go to.
    rewind() {
        if (!this.is_ready) {
            console.log("Cannot rewind unready figure")
        }
        const f = this.prevFrame()
        if (f) {
            this.currentFrame = f
            this.startCurrentFrame()
            return true
        } else {
            return false
        }
    }

    setRepeat(f) {
        this.repeat = f
    }
    setFadeColor(c) {
        this.fadeColor = c
    }

    // Whether this figure is at the end of the last frame
    isComplete() {
        return (this.nextFrame() == null) && (this.animationTime >= 1 || this.currentFrame.length == 0)
    }

    // Whether this figure is at the first frame
    isReset() {
        return (!this.currentFrame || this.Frames[0] == this.currentFrame)
    }

    complete() {
        this.currentFrame = this.Frames[this.Frames.length - 1]
        this.endCurrentFrame()
    }

    animate(frameLength, frameInterval, action, completedAction) {
        const t0 = new Date().getTime()
        let steps_rendered = 0
        this.interval = setInterval(() => {
            const t = new Date().getTime() - t0,
                  frac = t/frameLength
            this.animationTime = frac
            steps_rendered++
            if (frac >= 1) {
                this.animationTime = 1
                this.stopTimer()
                if (DEBUG)  {
                    console.log("rendered " + steps_rendered + " steps in time " + t +
                                " (" + Math.round(1000*steps_rendered/t) + "/sec)")
                }
                completedAction()
            } else {
                this.animationTime = frac
                action()
            }
        }, frameInterval)
    }

    // Start rendering (and animating, if necessary) the current frame
    startCurrentFrame() {
        this.animationTime = 0
        this.stopTimer()
        if (!this.currentFrame) {
            console.error("no current frame")
        }
        if (this.currentFrame.length > 0) {
            if (DEBUG) {
               console.log("starting animated frame " + this.currentFrame.name + " in " + this.name)
            }
            this.animate(this.currentFrame.length, 1000/this.frameRate,
                () => this.render(true),
                () => this.endCurrentFrame()
            )
        } else {
            if (DEBUG) {
               console.log("starting static frame " + this.currentFrame.name + " in " + this.name)
            }
            delete this.interval
            this.render(false)
        }
    }

    endCurrentFrame() {
        if (this.currentFrame === undefined) return
        if (DEBUG) {
          console.log("Ending frame " + this.currentFrame.name)
        }
        this.animationTime = 1
        this.stopTimer()
        this.render(false)
        if (this.nextFrame() && this.nextFrame().autoAdvance) {
            this.advance()
        }
    }

    stopTimer() {
        if (this.interval !== undefined) {
            clearInterval(this.interval)
            delete this.interval
        }
    }

    setAnimatedSolving(t) {
        this.animatedSolving = t
        if (t) {
            let counter = 0
            this.registerCallback(new SolverCallback("animateSolving",
                () => { counter++; return counter < 1000; }))
        } else {
            this.unregisterCallback("animateSolving")
        }
    }

// ---- default style control: some objects will use figure defaults if style parameters are not provided ----

    // Set the default fill style
    setFillStyle(style) {
        this.fillStyle = style
    }

    // Set the default stroke style
    setStrokeStyle(style) {
        this.strokeStyle = style
    }

    // Set the default text color/style
    setTextStyle(style) {
        this.textStyle = style
    }

    // Set the default line width
    setLineWidth(w) {
        this.lineWidth = w
    }

    // Set the default arrow size
    setArrowSize(s) {
        this.arrowSize = s
    }

    // Set default font size
    setFontSize(s) {
        this.font.setSize(s)
        return this
    }

    // Set default font name
    setFontName(n) {
        this.font.setName(n)
        return this
    }

    setFontStyle(sty) {
        this.font.setStyle(sty)
        return this
    }

    getFont() {
        return this.font.copy()
    }

    // Set default line spacing
    setLineSpacing(s) {
        this.lineSpacing = s
        return this
    }

    setConnectionStyle(s) {
        this.connectionStyle = s
        return this
    }



// ---- utility functions for creating constraints ----

    costEqual(cost, ...e) {
        if (e.length == 2) return new NearZero(this, new Minus(e[0], e[1]), cost)
        const a = []
        for (let i = 1; i < e.length; i++) {
            a.push(new NearZero(this, new Minus(e[0], e[i])), cost)
        }
        return new ConstraintGroup(this, a)
    }
    equal(...e) {
        if (e.length == 2) return new NearZero(this, new Minus(e[0], e[1]))
        const a = []
        for (let i = 1; i < e.length; i++) {
            a.push(new NearZero(this, new Minus(e[0], e[i])))
        }
        return new ConstraintGroup(this, a)
    }
    geq(...args) {
        if (args.length == 2) return new NearZero(this, new Relu(new Minus(args[1], args[0])))
        const a = []
        for (let i = 1; i < args.length; i++) {
            a.push(new NearZero(this, new Relu(new Minus(args[i], args[i-1]))))
        }
        return new ConstraintGroup(this, a)
    }
    positive(e) {
        return this.geq(e, 0)
    }
    leq(...args) {
        if (args.length == 2) return new NearZero(this, new Relu(new Minus(args[0], args[1])))
        const a = []
        for (let i = 1; i < args.length; i++) {
            a.push(new NearZero(this, new Relu(new Minus(args[i-1], args[i]))))
        }
        return new ConstraintGroup(this, a)
    }

    // constraints to pin all the objects at the same location
    pin(...objects) {
        objects = flattenGraphicalObjects(objects)
        const r = []
        for (let i = 1; i < objects.length; i++) {
            r.push(this.equal(objects[0].x(), objects[i].x()))
            r.push(this.equal(objects[0].y(), objects[i].y()))
        }
        if (r.length == 1) return r[0]
        else return new ConstraintGroup(this, r)
    }

    // Add a hint that value v is a good initial guess for the solution to expression e.
    hint(e, v) {
        if (e.constructor == Variable && typeof v == NUMBER) {
            e.setHint(v)
        } else {
            if (typeof v == NUMBER) {
                const variable = new Variable(this, "hint", v)
                this.equal(variable, e)
            } else if (Array.isArray(v)) {
                for (let i = 0; i < v.length; i++) {
                    const variable = new Variable(this, "hint_index_"+i, v[i])
                    this.equal(variable, new Projection(e, i, v.length))
                }
            }
        }
        return e
    }

    // Return a list of constraints that align a variable number of objects both
    // horizontal and vertically.
    // Allowed options for horizontal alignment:
    //    "none" : no alignment
    //    "left/right/center" : align left edges/center/right edges
    //    "abut" : make objects abut each other directly (see hspace() and vspace() for adding space)
    //    "distribute": objects have equal space separating them
    // Allowed options for vertical are the same except "top" and "bottom"
    //    replace "left" and "right".
    // Objects can either be passed as an array or as a variable number of arguments
    // starting from the third argument.
    align(horizontal, vertical, objlist) {
        const result = []
        if (!Array.isArray(objlist))
            objlist = argsToArray(arguments, 2)
        switch (horizontal) {
            case "none": break
            case "center": 
                for (let i = 1; i < objlist.length; i++)
                    result.push(this.equal(objlist[i].x(), objlist[0].x()))
                break
            case "left":
            case "L":
                for (let i = 1; i < objlist.length; i++)
                    result.push(this.equal(objlist[i].x0(), objlist[0].x0()))
                break
            case "right":
            case "R":
                for (let i = 1; i < objlist.length; i++)
                    result.push(this.equal(objlist[i].x1(), objlist[0].x1()))
                break
            case "left right":
            case "right left":
            case "LR":
            case "RL":
                for (let i = 1; i < objlist.length; i++) {
                    result.push(this.equal(objlist[i].x0(), objlist[0].x0()))
                    result.push(this.equal(objlist[i].x1(), objlist[0].x1()))
                }
                break
            case "abut":
                for (let i = 1; i < objlist.length; i++)
                    result.push(this.equal(objlist[i-1].x1(), objlist[i].x0()))
                break
            case "distribute":
                const d = new Minus(objlist[1].x0(), objlist[0].x1())
                for (let i = 2; i < objlist.length; i++) {
                    result.push(this.equal(new Minus(objlist[i].x0(), objlist[i-1].x1()), d))
                    result.push(this.geq(objlist[i].x0(), objlist[i-1].x1()))
                }
                break
        }
        switch (vertical) {
            case "none": break
            case "center": 
                for (let i = 1; i < objlist.length; i++)
                    result.push(this.equal(objlist[i].y(), objlist[0].y()))
                break
            case "top":
            case "T":
                for (let i = 1; i < objlist.length; i++)
                    result.push(this.equal(objlist[i].y0(), objlist[0].y0()))
                break
            case "bottom":
            case "B":
                for (let i = 1; i < objlist.length; i++)
                    result.push(this.equal(objlist[i].y1(), objlist[0].y1()))
                break
            case "top bottom":
            case "bottom top":
            case "TB":
            case "BT":
                for (let i = 1; i < objlist.length; i++) {
                    result.push(this.equal(objlist[i].y0(), objlist[0].y0()))
                    result.push(this.equal(objlist[i].y1(), objlist[0].y1()))
                }
                break
            case "abut":
                for (let i = 1; i < objlist.length; i++)
                    result.push(this.equal(objlist[i-1].y1(), objlist[i].y0()))
                break
            case "distribute":
                const d = new Minus(objlist[1].y0(), objlist[0].y1())
                for (let i = 2; i < objlist.length; i++) {
                    result.push(this.equal(new Minus(objlist[i].y0(), objlist[i-1].y1()), d))
                    result.push(this.geq(objlist[i].y0(), objlist[i-1].y1()))
                }
                break
        }
        return result
    }
    // keep g1 inside the bounds of g2
    keepInside(g1, g2) {
        return new ConstraintGroup(this,
            this.leq(g1.x1(), g2.x1()),
            this.leq(g1.y1(), g2.y1()),
            this.geq(g1.x0(), g2.x0()),
            this.geq(g1.y0(), g2.y0()))
    }
    // keep g1 and g2 the same size
    sameSize(...objs) {
        return new ConstraintGroup(this,
            this.equal(...objs.map(o => o.w())),
            this.equal(...objs.map(o => o.h())))
    }

    after(frame, ...objs) {
        if (objs.length == 1) return new After(this, frame, objs[0])
        return objs.flat().map(o => new After(this, frame, o))
    }
    before(frame, ...objs) {
        if (objs.length == 1) return new Before(this, frame, objs[0])
        objs.flat().map(o => new Before(this, frame, o))
    }
    between(frame1, frame2, ...objs) {
        if (objs.length == 1) return new Before(this, frame2, new After(this, frame1, objs[0]))
        objs.flat().map(o => new Before(this, frame2, new After(this, frame1, o)))
    }
    drawAfter(frame, ...objs) {
        if (objs.length == 1) return new DrawAfter(this, frame, objs[0])
        return objs.flat().map(o => new DrawAfter(this, frame, o))
    }
    drawBefore(frame, ...objs) {
        if (objs.length == 1) return new DrawBefore(this, frame, objs[0])
        objs.flat().map(o => new DrawBefore(this, frame, o))
    }
    drawBetween(frame1, frame2, ...objs) {
        if (objs.length == 1) return new DrawBefore(this, frame2, new DrawAfter(this, frame1, objs[0]))
        objs.flat().map(o => new DrawBefore(this, frame2, new DrawAfter(this, frame1, o)))
    }

// ---- Utility methods for creating figure objects ----

    canvasRect() {
        return new CanvasRect(this.figure)
    }
    rectangle(fillStyle, strokeStyle, lineWidth, x_hint, y_hint, w_hint, h_hint) {
        return new Rectangle(this, fillStyle, strokeStyle, lineWidth, x_hint, y_hint, w_hint, h_hint)
    }
    square(fillStyle, strokeStyle, lineWidth, x_hint, y_hint, w_hint) {
        return new Square(this, fillStyle, strokeStyle, lineWidth, x_hint, y_hint, w_hint)
    }
    circle(fillStyle, strokeStyle, lineWidth, x_hint, y_hint, w_hint) {
        return new Circle(this, fillStyle, strokeStyle, lineWidth, x_hint, y_hint, w_hint)
    }
    ellipse(fillStyle, strokeStyle, lineWidth, x_hint, y_hint, r_hint) {
        return new Ellipse(this, fillStyle, strokeStyle, lineWidth, x_hint, y_hint, r_hint)
    }
    polygon(...points) {
        return new Polygon(this, points)
    }
    closedCurve(...points) {
        return new ClosedCurve(this, points)
    }
    line(strokeStyle, lineWidth, start, end) {
        return new Line(this, strokeStyle, lineWidth, start, end)
    }
    horzLine(strokeStyle, lineWidth, start, end) {
        return new HorzLine(this, strokeStyle, lineWidth, start, end)
    }
    vertLine(strokeStyle, lineWidth, start, end) {
        return new VertLine(this, strokeStyle, lineWidth, start, end)
    }
    hspace(w) {
        const r = new HSpace(this, w)
        return r
    }
    vspace(h) {
        const r = new VSpace(this, h)
        return r
    }
    box() { return new Box(this) }
    text(...t) { return createText(...t) }
    superscript(...t) {
        return new SuperscriptText(createText(...t))
    }
    subscript(...t) {
        return new SubscriptText(createText(...t))
    }
    italic(...t) {
        return new ItalicText(createText(...t))
    }
    bold(...t) {
        return new BoldText(createText(...t))
    }
    fontName(name, ...t) {
        return this.textContext(tc => {
            const f = tc.get("font").copy();
            f.setName(name)
            return tc.set("font", f)
        }, ...t)
    }
    fontSize(size, ...t) {
        return this.textContext(tc => {
            const f = tc.get("font").copy();
            f.setSize(size)
            return tc.set("font", f)
        }, ...t)
    }
    textColor(c, ...t) {
        return this.textContext(tc => tc.set("fillStyle", c), ...t)
    }
    hyphen() {
        return new Hyphen()
    }
    br() {
        return new LineBreak()
    }
    word(w) {
        return new WordText(w)
    }
    whitespace() {
        return new Whitespace()
    }
    textContext(f, ...t) {
        return new ContextTransformer(tc => f(new TextContext(tc)), createText(...t))
    }
    textFrame(txt, fillStyle) {
        if (txt && txt.constructor != ContainedText) txt = new ContainedText(this, txt)
        return new TextFrame(this, txt, fillStyle)
    }
    label(text, fontSize, fontName, fillStyle) {
        return new Label(this, text, fontSize, fontName, fillStyle)
    }
    lineLabel(string, position, offset) {
        return new LineLabel(this, string, position, offset)
    }
    handle(style) {
        return new Handle(this, style)
    }
    connector(...objects) {
        return new Connector(this, ...objects)
    }
    DOMElement(id) {
        return new DOMElementBox(this, id)
    }
    group(...objects) {
        return new Group(this, ...objects)
    }
    linear(frame, e1, e2) {
        return new Linear(this, frame, e1, e2)
    }
    smooth(frame, e1, e2) {
        return new Smooth(this, frame, e1, e2)
    }
    variable(name, hint) {
        return new Variable(this, name, hint)
    }
    projection(expr, i, n) {
        return new Projection(expr, i, n)
    }

    // Create a point with variables for its coordinates
    point() {
        if (arguments.length == 2) {
            return new Point(legalExpr(arguments[0]), legalExpr(arguments[1]))
        } else {
            if (arguments.length != 0) {
                console.error("point(...) expects 0 or 2 arguments")
            }
            const x = new Variable(this, "px"), y = new Variable(this, "py")
            return new Point(x, y)
        }
    }
    advanceButton() {
        return new AdvanceButton(this)
    }
    makeGraph() {
        if (!Constrain.Graph) {
            alert("Can't find Graph class. Did you forget to load constrain-graph.js?")
            return
        }
        const g = new Constrain.Graph(this)
        this.Graphs.push(g)
        return g
    }
// ---- Utility methods for creating expressions ----

    plus(...args) {
        args = args.flat().map(a => legalExpr(a))
        switch (args.length) {
            case 0: return 0
            case 1: return args[0]
            case 2: return new Plus(...args)
            default: return new Plus(args[0], ...args.slice(1))
        }
    }
    minus(x, y) {
        return new Minus(legalExpr(x), legalExpr(y))
    }
    times(...args) {
        args = args.flat().map(a => legalExpr(a))
        switch (args.length) {
            case 0: return 1
            case 1: return args[0]
            case 2: return new Times(...args)
            default: return new Times(args[0], ...args.slice(1))
        }
    }
    divide(x, y) {
        return new Divide(legalExpr(x), legalExpr(y))
    }
    abs(e) { return new Abs(legalExpr(e)) }
    max(...args) {
        args = args.flat().map(a => legalExpr(a))
        return new Max(...args)
    }
    min(...args) {
        args = args.flat().map(a => legalExpr(a))
        return new Min(...args)
    }
    sqrt(x) { return new Sqrt(legalExpr(x)) }
    sqr(x) { return new Sq(legalExpr(x)) }
    sq(x) { return new Sq(legalExpr(x)) }
    average(x, y) { return new Average(legalExpr(x), legalExpr(y)) }
    distance(p1, p2, dims) { return new Distance(legalExpr(p1), legalExpr(p2), dims) }
    nearZero(e, cost) { return new NearZero(this, legalExpr(e), cost) }
    constraintGroup(...c) { return new ConstraintGroup(this, ...c) }
    group(...g) { return new Group(this, ...g) }
    // constraint that (p1 -> p2) is perpendicular to (p3->p4)
    perpendicular(p1, p2, p3, p4) {
        let v1 = new Minus(legalExpr(p2), legalExpr(p1)), v2 = new Minus(legalExpr(p4), legalExpr(p3))
        return new NearZero(this,
            new Plus(new Times(new Projection(v1, 0, 2), new Projection(v2, 0, 2)),
                     new Times(new Projection(v1, 1, 2), new Projection(v2, 1, 2))))
    }

// dy1/dx1 = dy2/dx2 <==> dy1*dx2 = dy2 * dx1
    collinear() {
      switch (arguments.length) {
        case 0: case 1: case 2: console.error("collinear expects at least 3 points"); return;
        case 3:
            let p0 = arguments[0], p1 = arguments[1], p2 = arguments[2]
            return this.equal(
                this.times(this.minus(p1.y(), p0.y()), this.minus(p2.x(), p0.x())),
                this.times(this.minus(p2.y(), p0.y()), this.minus(p1.x(), p0.x())))
        default:
          let result = []
          for (let i = 2; i < arguments.length; i++) {
            result.push(this.collinear(arguments[0], arguments[1], arguments[i]))
          }
          return new ConstraintGroup(this, ...result)
      }
    }

    between(p0, p1, p2) {
        let a = this.variable("a", 0.5), b = this.minus(1, a)
        return new ConstraintGroup(this,
            this.geq(a, 0),
            this.leq(a, 1),
            this.equal(p0.x(), this.plus(this.times(a, p1.x()), this.times(b, p2.x()))),
            this.equal(p0.y(), this.plus(this.times(a, p1.y()), this.times(b, p2.y())))
        )
    }
// dy1/dx1 = dy2/dx2 <==> dy1*dx2 = dy2 * dx1
// make p0-p1 parallel to p2-p3
    parallel(p0, p1, p2, p3) {
        return this.equal(
          this.times(this.minus(p1.y(), p0.y()), this.minus(p3.x(), p2.x())),
          this.times(this.minus(p3.y(), p2.y()), this.minus(p1.x(), p0.x())))
    }
}

function figure(nm) {
    return new Figure(nm)
}

function isFigure(figure) {
    return (figure.connector !== undefined)
}

// A callback that the solver will invoke if registered via Figure.registerCallback()
class SolverCallback {
    constructor(name, f) {
        this.name = name
        this.fun = f
    }
    call(it, x0, f0, g0, H1) {
        return (this.fun)(it, x0, f0, g0, H1)
    }
}

// Return which Figure is associated with element e, or null if
// none (for example, if e is not a canvas or (somehow) inside a canvas).
function canvasToFigure(e) {
    while (e != null) {
        if (e.nodeName == "CANVAS") break
        e = e.parentElement
    }
    if (e == null) return null
    for (let i = 0; i < Figures.length; i++) {
        if (Figures[i].canvas == e) return Figures[i]
    }
    return null
}

// add event listeners for touch events in canvases
function setupTouchListeners() {
    window.addEventListener('touchstart',
        e => {
            const figure = canvasToFigure(e.target)

            if (!figure || figure.interactives.length == 0) return true
            const t = e.targetTouches,
                  r = figure.canvas.getClientRects()[0],
                  touch = t.item(0),
                  x = touch.clientX - r.left,
                  y = touch.clientY - r.top
            for (let i = 0; i < figure.interactives.length; i++) {
                const h = figure.interactives[i]
                if (!h.mousedown(x, y, e)) {
                    e.preventDefault()
                    e.stopImmediatePropagation()
                    return false
                }
            }
            return true
        }, {passive: false})

    window.addEventListener('touchmove',
        e => {
            const figure = canvasToFigure(e.target)
            if (!figure || figure.interactives.length == 0) return true
            const t = e.targetTouches,
                  r = figure.canvas.getClientRects()[0],
                  touch = t.item(0),
                  x = touch.clientX - r.left,
                  y = touch.clientY - r.top
            if (!figure.focused) return true
            e.preventDefault()
            e.stopImmediatePropagation()
            return figure.focused.mousemove(x, y, e)
        }, {passive: false})

    window.addEventListener('touchend',
        e => {
            const figure = canvasToFigure(e.target)
            if (!figure || figure.interactives.length == 0) return true
            if (!figure.focused) return true
            e.preventDefault()
            e.stopImmediatePropagation()
            return figure.focused.mouseup(e)
        }, {passive: false})
}

const UNCMIN_GRADIENT = 0, UNCMIN_BFGS = 1, UNCMIN_DFP = 2, UNCMIN_ADAM = 3, UNCMIN_LBFGS = 4
const algorithm = UNCMIN_BFGS

const CALLBACK_RETURNED_TRUE = "Callback returned true",
      BAD_SEARCH_DIRECTION = "Search direction has Infinity or NaN",
      BAD_GRADIENT = "Gradient has Infinity or NaN"

const ADAM_BETA1 = 0.9, ADAM_BETA2 = 0.999, ADAM_EPSILON = 1e-8
const UNCMIN_OVERSHOOT = 0.1, UNCMIN_STEPSIZE = 1
const UNCMIN_LBFGS_M = 10

function partition(a, l, r) {
    const p = a[l] // better: swap a[l] with random element first
    let i = l, j = r
    j--
    while (a[j] > p) j--
    while (i < j) {
        const t = a[i]; a[i] = a[j]; a[j] = t
        i++
        while (a[i] < p) i++
        j--
        while (a[j] > p) j--
    }
    return j+1
}

// Adapted from numeric-1.2.6.js to allow f to supply the gradient directly. Uses
// various functions from that package.
//
// Returns: a local minimum of a function f(x) whose gradient is g(x), using
//   a BFGS gradient descent search.
// Requires: fg(x) or fg(x, false) must return just f(x),
//   fg(x, true) must return [ f(x), (grad f)(x)] or [f(x0), undefined]. In the former case,
//   (grad f) must return an array whose length is the same as x. In the latter
//   case, a numeric gradient is computed using f, probably more expensively.
//   If the computed gradient is infinite or contains NaN, the search terminates.
// Effects: if callback is a function, it is invoked on each iteration of the algorithm.
//    If it returns true, the search for the local minimum halts.
function uncmin(fg, x0, tol, maxit, callback, options) {
    const grad = numeric.gradient,
        dot = numeric.dot,
        sub = numeric.sub,
        add = numeric.add,
        ten = numeric.tensor,
        div = numeric.div,
        sqrt = numeric.sqrt,
        mul = numeric.mul,
        transpose = numeric.transpose,
        all = numeric.all,
        isfinite = numeric.isFinite,
        neg = numeric.neg
    if (options === undefined) options = {}
    tol = options.tol || 1e-8
    maxit = options.maxit || 1000

    const gradient = x => grad(fg, x)
    x0 = numeric.clone(x0)
    const n = x0.length
    let [f0, g0] = fg(x0, true)
    let f1, g1, df0
    if (isNaN(f0))
        throw new Error('uncmin: f(x0) is a NaN!')
    if (g0 === undefined) g0 = gradient(x0)
    const idn = numeric.identity(n)
    const max = Math.max,
        norm2 = numeric.norm2
    tol = max(tol, numeric.epsilon)
    let step, H1 = options.Hinv || mul(numeric.identity(n), options.stepSize || 1)
    if (H1.length != n) {
        throw new Error("Inverse Hessian has wrong dimensions")
    }

    let it = 0,
        i, s, x1, y, ys, Hs, i0, t, nstep, t1, t2,
        m, v // ADAM
    let overshoot = options.overshoot || 0.1
    let msg = ""
    if (algorithm == UNCMIN_ADAM) {
        m = getZeros(n)
        v = getZeros(n)
    }
    let hist, y_hist, s_hist, rho // L-BFGS
    if (algorithm == UNCMIN_LBFGS) {
        if (options.Hinv) {
            hist = options.Hinv.hist
            y_hist = options.Hinv.y_hist
            s_hist = options.Hinv.s_hist
            rho = options.Hinv.rho
        } else {
            hist = 0 // the m of L-BFGS
            y_hist = []; s_hist = []; rho = [] // length of each is hist
        }
    }
    while (it < maxit) {
        if (!all(isfinite(g0))) {
            msg = BAD_GRADIENT
            break
        }
        t = 1.0
        switch (algorithm) {
            case UNCMIN_BFGS:
            case UNCMIN_DFP:
                step = neg(dot(H1, g0))
                break
            case UNCMIN_LBFGS: {
                    let q = g0
                    const alpha = new Array(hist)
                    for (let i = hist-1; i >= 0; i--) {
                        alpha[i] = rho[i] * dot(s_hist[i], q)
                        q = sub(q, mul(alpha[i], y_hist[i]))
                    }
                    const gamma = // use rho for numerator?
                        hist > 0 ? dot(s_hist[hist-1], y_hist[hist-1])/dot(y_hist[hist-1], y_hist[hist-1])
                                 : 1
                    let z = mul(gamma, q)
                    for (let i = 0; i < hist; i++) {
                        const beta_i = rho[i] * dot(y_hist[i], z)
                        z = add(z, mul(s_hist[i], alpha[i] - beta_i))
                    }
                    step = neg(z)
                }

                break
            case UNCMIN_GRADIENT:
                step = neg(g0)
                break
            case UNCMIN_ADAM:
                m = add(mul(ADAM_BETA1, m), mul(1 - ADAM_BETA1, g0))
                v = add(mul(ADAM_BETA2, v), mul(1 - ADAM_BETA2, mul(g0, g0)))
                step = div(mul(-t, m), add(sqrt(v), ADAM_EPSILON))
                break
        }

        if (!all(isfinite(step))) {
            msg = BAD_SEARCH_DIRECTION
            break
        }
        nstep = norm2(step)
        if (nstep < tol) {
            msg = "Newton step smaller than tol"
            break
        }
        df0 = dot(g0, step)
        // line search
        x1 = x0
        while (it < maxit) {
            if (t * nstep < tol) {
                break
            }
            s = mul(step, t)
            x1 = add(x0, s)
            f1 = fg(x1)
            if (algorithm != UNCMIN_ADAM && f1 - f0 >= overshoot * t * df0 || isNaN(f1)) {
                t *= 0.5
                it++
                continue
            }
            break
        }
        if (t * nstep < tol/10) {
            msg = "Line search step size smaller than tol"
            break
        }
        if (it === maxit) {
            msg = "maxit reached during line search"
            break
        }
        [f1, g1] = fg(x1, true)
        if (g1 === undefined) g1 = gradient(x1)
        switch (algorithm) {
            case UNCMIN_BFGS: {
                y = sub(g1, g0)
                ys = dot(y, s)
                if (ys <= 0) {
                    H1 = numeric.identity(n) // inverse Hessian looks broken, restart
                    console.log("resetting inverse Hessian estimate")
                } else {
                    const Hy = dot(H1, y)
                    H1 = sub(add(H1,
                                mul((ys + dot(y, Hy)) / (ys * ys),
                                    ten(s, s))),
                            div(add(ten(Hy, s), ten(s, Hy)), ys))
                }
            }
            break

            case UNCMIN_DFP: {
                y = sub(g1, g0)
                const ys = dot(y, s)
                const yHy = dot(y, Hy),
                    t1 = mul(ten(Hy, Hy), -1/yHy),
                    t2 = mul(ys, ten(s,s))
                H1 = add(add(H1, t1), t2)
            }
            break

            case UNCMIN_LBFGS: {
                y = sub(g1, g0)
                s_hist.push(s)
                y_hist.push(y)
                rho.push(1/dot(y, s))
                hist++
                if (hist > UNCMIN_LBFGS_M) {
                    s_hist.shift()
                    y_hist.shift()
                    rho.shift()
                    hist--
                }
            }

            default: break
        }
        x0 = x1
        f0 = f1
        g0 = g1
        it++
        if (typeof callback === FUNCTION) {
            if (callback(it, x0, f0, g0, H1)) {
                msg = CALLBACK_RETURNED_TRUE
                break
            }
        }
    }
    if (algorithm == UNCMIN_LBFGS) {
        H1 = { hist: hist, s_hist: s_hist, y_hist: y_hist, rho: rho }
    }
    return {
        solution: x0,
        f: f0,
        gradient: g0,
        invHessian: H1,
        iterations: it,
        message: msg
    }
}

// A frame of the animation. Frames can auto-advance
// to the next frame or require manual advancing.
// frame.index gives the index of the frame in the
// current figure.
class Frame {
    constructor(figure, name) {
        if (name === undefined) name = figure.Frames.length
        if (!isFigure(figure)) {
            console.error("First argument to new Frame() must be a figure")
        }
        this.index = figure.Frames.length
        this.name = name
        figure.Frames.push(this)
        this.autoAdvance = false
        this.length = 0
    }
    // Set the length of this frame (ms)
    setLength(ms) {
        this.length = ms
        return this
    }
    setAutoAdvance(a) {
        this.autoAdvance = a
        return this
    }
    isAfter(f) {
        return this.index >= f.index
    }
    isBefore(f) {
        return this.index < f.index
    }
    toString() {
        return "Frame " + this.name
    }
}

function eventInElement(event, element) {
    const rect = element.getBoundingClientRect()
    const x = event.clientX
    if (x < rect.left || x >= rect.right) return false
    const y = event.clientY
    if (y < rect.top || y >= rect.bottom) return false
    return true
}

// An Expression is used to build constraints or and to express useful
// quantities in terms of the solved-for values of variables.
class Expression {
    constructor() {}
    evaluate(valuation, doGrad) {
        console.error("Don't know how to evaluate this expression")
        return 0
    }
    // support for caching evaluations. Mostly not worthwhile but can pay off for
    // reused expressions.
    checkCache(valuation, doGrad) {
        doGrad = doGrad ? true : false
        if (this.cachedValuation !== valuation || doGrad > this.cachedDoGrad) {
            cacheMisses++
            return undefined
        }
        cacheHits++
        if (doGrad == this.cachedDoGrad) return this.cachedResult
        return this.cachedResult[0]
    }
    recordCache(valuation, doGrad, result) {
        doGrad = doGrad ? true : false
        this.cachedValuation = valuation
        this.cachedDoGrad = doGrad
        this.cachedResult = result
        return result
    }
    variables() { return [] }
    initDiff() { this.bpDiff = 0 }
    // actually propagate differentials backward to dependencies
    backprop(task) {
        console.error("Don't know how to back-propagate this expression")
    }
    addDependencies(task) {
        console.error("Don't know how to compute dependencies for this expression")
    }
}

/** Return e if it is a legal expression; otherwise, return a
    *  legal expression and log an error message to the console.
    */
function legalExpr(e) {
    if (e instanceof Expression ||
        typeof e == "number" ||
        (typeof e == "object" && e.constructor == Array)) {
            return e;
    }
    console.error("Illegal expression: " + e)
    return 0;
}

function currentValue(e) {
    if (typeof e === NUMBER) {
        return e
    } else {
        return e.currentValue
    }
}

// A Variable is solved for by the constraint solver. It does not
// keep track of its own value. A variable has an index that determines
// its location in the valuation array.
//
// XXX Does it really need to know its figure?
class Variable extends Expression {
    constructor(figure, basename, hint) {
        super()
        this.basename = basename + "_" + figure.numVariables
        this.index = figure.numVariables // overridden later by numberVariables()
        this.figure = figure
        figure.Variables.push(this)
        figure.numVariables++
        if (hint !== undefined) {
            this.hint = hint
        }
    }
    evaluate(valuation, doGrad) {
        if (this.index === undefined) {
            console.error("Can't evaluate a variable that has not been solved for")
            return 0
        }
        if (doGrad) {
            let g = this.grad, n = valuation.length
            if (!g || g.length != n) {
                g = new Array(n).fill(0)
                g[this.index] = 1
                this.grad = g // save gradient for later
            }
            if (this.figure.activeVariables[this.index] !== this) {
                console.error("Variable index does not agree with active variables list")
            }
            return [valuation[this.index], g]
        } else {
            return valuation[this.index]
        }
    }
    backprop(valuation, d) {}
    addDependencies(task) {}

    setHint(v) {
        this.hint = v
    }
    setIndex(n) {
        this.index = n
    }
    removeIndex() {
        delete this.index
    }
    toString() {
        return this.basename
    }
    variables() { return [this] }
}

// This variable caches an array of zeros of the appropriate length
var zeros

// Return an array of zeros of length n. It may not be mutated. 
function getZeros(n) {
    if (zeros && zeros.length == n) return zeros
    zeros = new Array(n).fill(0)
    return zeros
}

var cacheHits = 0, cacheMisses = 0

function statistics() {
    return {
        cacheHits: cacheHits,
        cacheMisses: cacheMisses,
    }
}

// The variables used by expression e.
function exprVariables(e) {
    if (e === undefined)
        console.error("undefined expr")
    if (typeof e === NUMBER || e.constructor == Array) return []
    if (!e.variables)
        console.error("no variables method")
    return e.variables()
}

// The value of expression expr in the given valuation (an array of variable values).
// If doGrad is true, it returns an array [v, g] where is the value of the expression and
// g is its gradient with respect to all the variables.
function evaluate(expr, valuation, doGrad) {
    // alert("evaluating " + expr)
    /*
    if (expr === undefined) {
        console.error("undefined expr")
    }
    if (valuation === undefined) {
        console.error("undefined valuation")
    }
    if (CACHE_ALL_EVALUATIONS && expr.checkCache) {
        const v = expr.checkCache(valuation, doGrad)
        if (v) return v
    }
    */
    switch (typeof expr) {
        case NUMBER: return !doGrad ? expr : [ expr, getZeros(valuation.length) ]
        case FUNCTION:
            console.error("Tried to evaluate a function ${expr}. Did you forget to invoke a property using ()?")
            return 0
        default:
            if (Array.isArray(expr)) {
                return expr.map(e => evaluate(e, valuation, doGrad))
            } else {
                if (CACHE_ALL_EVALUATIONS) {
                    return expr.currentValue = expr.recordCache(valuation, doGrad, expr.evaluate(valuation, doGrad))
                } else {
                    const r = expr.evaluate(valuation, doGrad)
                    expr.currentValue = r
                    return r
                }
            }
    }
}

function checkNaNResult(r) {
    if (Array.isArray(r)) {
        const [c, dc] = r
        if (isNaN(c)) {
            console.error("Saw NaN in computed value (with grad)")
            return true
        }
        for (let i = 0; i < dc.length; i++) {
            if (isNaN(dc[i])) {
                console.error("Saw NaN in computed gradient")
                return true
            }
        }
    } else if (isNaN(r)) {
        console.error("Saw NaN in computed value")
        return true
    }
    return false
}

function checkDiffValid(d) {
    if (typeof d === NUMBER && isNaN(d) ||
        typeof d === OBJECT_STR && (isNaN(d[0]) || isNaN(d[1])))
    {
        console.error("Asked to propagate NaN")
        return false
    }
    return true
}

// A back-propagation task. It computes the differential of a sum of functions
// wrt each subexpression at the given valuation.  Only one such task can be
// running at a given time because state is stored in expression nodes.
class BackPropagation {
    // create a task for computing differentials at the
    // specified valuation
    constructor(variables) {
        // this.exprs contains all the expressions that are in the expression
        // AST/DAG, in reverse postorder so that they can be propagated in a single
        // left-to-right pass
        this.exprs = []
        this.variables = variables
    }

    run(valuation) {
        this.valuation = valuation
        const es = this.exprs, n = valuation.length, vs = this.variables
        for (let i = 0; i < es.length; i++) {
            const e = es[i]
            if (!e.bpRoot) e.initDiff()
        }
        for (let i = es.length - 1; i >= 0; i--) {
            const e = es[i]
            if (e.currentValue === undefined) {
                console.error("Has an undefined value: " + e)
                console.log("trying again: ", evaluate(e, valuation))
            }
            if (e.bpDiff == 0) continue
            e.backprop(this)
        }
    }

    // back-propagate the differential value d to expr
    propagate(expr, d) {
        // console.log("propagate: " + expr + " <- " + d)
        if (typeof expr !== NUMBER && expr.bpDiff === undefined) {
            console.error("bpDiff not defined")
        }
        if (CHECK_NAN && !checkDiffValid(d)) {
            console.error("Asked to propagate invalid diff")
        }
        switch (typeof expr) {
            case NUMBER: return // nothing to do
            case FUNCTION: console.error("something is broken")
            default:
                if (expr.bpTask !== this)
                    console.error("expr does not belong to correct backprop")

                if (typeof d === NUMBER) {
                    if (Array.isArray(expr.bpDiff)) {
                        console.error("Can't update an array-valued expression with a scalar")
                    }
                    expr.bpDiff += d
                }
                else if (Array.isArray(d)) {
                    expr.bpDiff = numeric.add(expr.bpDiff, d)
                } else {
                    console.error("attempt to backpropagate something of the wrong type")
                }
                if (CHECK_NAN && isNaN(expr.bpDiff) && isNaN(expr.bpDiff[0])) {
                    console.error("oops")
                }
        }
    }
    // Add this expression as something to minimize
    addTask(expr, cost) {
        this.prepareBackProp(expr)
        if (isNaN(cost)) {
            console.error("cost is not a number!?")
        }
        expr.bpDiff = cost
        expr.bpRoot = true
    }
    prepareBackProp(expr) {
        if (typeof expr === NUMBER) return
        if (expr.bpTask === this) return // already visited
        expr.bpTask = this
        expr.addDependencies(this)
        this.exprs.push(expr)
    }
}

// A binary expression like +, *, -, /
class BinaryExpression extends Expression {
    constructor(e1, e2) {
        super()
        if (e1 === undefined)
            console.error("undefined e1")
        if (e2 === undefined)
            console.error("undefined e2")
        this.e1 = e1
        this.e2 = e2
        return this
    }
    toString() {
        return this.e1 + this.opName() + this.e2
    }
    opName() { return " binop " }
    evaluate(valuation, doGrad) {
        if (!doGrad || !this.gradop)
            return this.operation(evaluate(this.e1, valuation), evaluate(this.e2, valuation))
        const [a, da] = evaluate(this.e1, valuation, true)
        const [b, db] = evaluate(this.e2, valuation, true)
        return this.gradop(a, b, da, db)
    }
    addDependencies(task) {
        task.prepareBackProp(this.e1)
        task.prepareBackProp(this.e2)
    }
    variables() {
        return exprVariables(this.e1).concat(exprVariables(this.e2))
    }
}

// An expression x - y
class Minus extends BinaryExpression {
    constructor(e1, e2) { super(e1, e2) }
    operation(a, b) { return numeric.sub(a, b) }
    gradop(a, b, da, db) {
        return [numeric.sub(a, b), numeric.sub(da, db)]
    }
    backprop(task) {
        task.propagate(this.e1, this.bpDiff)
        task.propagate(this.e2, numeric.neg(this.bpDiff))
    }
    opName() { return "-" }
}

// An expression x + y
class Plus extends BinaryExpression {
    constructor(e1, e2) { super(e1, e2) }
    operation(a, b) { return numeric.add(a, b) }
    gradop(a, b, da, db) { return [numeric.add(a, b), numeric.add(da, db)] }
    backprop(task) {
        task.propagate(this.e1, this.bpDiff)
        task.propagate(this.e2, this.bpDiff)
    }
    opName() { return "+" }
}

// The average of two numbers or points
class Average extends BinaryExpression {
    constructor(e1, e2) { super(e1, e2) }
    operation(a, b) { return numeric.mul(0.5, numeric.add(a, b)) }
    gradop(a, b, da, db) {
        return [ numeric.mul(0.5, numeric.add(a, b)), numeric.mul(numeric.add(da, db), 0.5) ]
    }
    backprop(task) {
        task.propagate(this.e1, numeric.mul(0.5, this.bpDiff))
        task.propagate(this.e2, numeric.mul(0.5, this.bpDiff))
    }
    opName() { return " avg " }
    x() { return new Projection(this, 0, 2) }
    y() { return new Projection(this, 1, 2) }
    h() { return 0 }
    w() { return 0 }
}

// An expression x * y
class Times extends BinaryExpression {
    constructor(e1, e2) { super(e1, e2) }
    operation(a, b) { return a * b }
    gradop(a, b, da, db) {
        return [ a * b, numeric.add(numeric.mul(a, db), numeric.mul(b, da)) ]
    }
    backprop(task) {
        const a = currentValue(this.e1),
              b = currentValue(this.e2),
              d = this.bpDiff
        task.propagate(this.e1, numeric.mul(d,b))
        task.propagate(this.e2, numeric.mul(d,a))
    }
    opName() { return " * " }
}

// An expression x / y
class Divide extends BinaryExpression {
    constructor(e1, e2) { super(e1, e2) }
    operation(a, b) {
        if (b == 0) console.log("warning: divide by zero, using random answer")
        return b == 0 ? Math.random() - 0.5 : a / b }
    gradop(a, b, da, db) {
        return [a / b, numeric.add(numeric.mul(-a/(b*b), db),  numeric.mul(da, 1/b))]
    }
    backprop(task) {
        // d/da (a / b) = 1/b
        // d/db (a / b) = a * d/db(1/b) = a * (-1/b^2) = -a/b^2
        const a = currentValue(this.e1),
              b = currentValue(this.e2),
              ib = (b == 0) ? Math.random() - 0.5 : 1/b,
              d = this.bpDiff
        if (b == 0) console.log("warning: divide by zero, using random answer")
        task.propagate(this.e1, ib*d)
        task.propagate(this.e2, numeric.mul(a, -ib*ib*d))
    }
    opName() { return "/" }
}

// An expression that expects an arbitrary number of arguments.
class NaryExpression extends Expression {
    constructor(...arglist) {
        super()
        this.args = arglist.flat()
    }
    evaluate(valuation, doGrad) {
        const vals = this.args.map(e => evaluate(e, valuation, doGrad))
        if (doGrad) return this.gradop(vals)
        else return this.operation(vals)
    }
    variables() {
        let result = []
        this.args.forEach(e => { result = result.concat(exprVariables(e)) })
        return result
    }
    backprop(task) { // for ops like min and max that depend on only on argument this.which
        const n = this.args.length, d = this.bpDiff
        task.propagate(this.args[this.which], d)
    }
    addDependencies(task) {
        this.args.forEach(e => task.prepareBackProp(e))
    }
}

// The minimum of some number of arguments.
class Min extends NaryExpression {
    constructor(...args) { super(...args) }
    operation(vals) {
        let best = vals[0], n = vals.length, besti = 0
        for (let i = 1; i < n; i++) {
            if (best > vals[i]) {
                best = vals[i]
                besti = i
            }
        }
        this.which = besti
        return best
    }
    gradop(vals) {
        let [best, db] = vals[0], n = vals.length, besti = 0
        for (let i = 1; i < n; i++) {
            let [a, da] = vals[i]
            if (a < best) {
                best = a
                db = da
                besti = i
            }
        }
        this.which = besti
        return [best, db]
    }
    toString() { return "min(" + this.args + ")" }
}

// The maximum of some number of arguments.
class Max extends NaryExpression {
    constructor(...args) { super(...args) }
    operation(vals) {
        let best = vals[0], n = vals.length, besti = 0
        for (let i = 1; i < n; i++) {
            if (best < vals[i]) {
                best = vals[i]
                besti = i
            }
        }
        this.which = besti
        return best
    }
    gradop(vals) {
        let [best, db] = vals[0], n = vals.length, besti = 0
        for (let i = 1; i < n; i++) {
            let [a, da] = vals[i]
            if (a > best) {
                best = a
                db = da
                besti = i
            }
        }
        this.which = besti
        return [best, db]
    }
    toString() { return "max(" + this.args + ")" }
}

// The distance between two points
class Distance extends Expression {
    constructor(p1, p2, dim) {
        super()
        this.p1 = p1
        this.p2 = p2
        this.dim = dim || 2
    }
    evaluate(valuation, doGrad) {
      if (!doGrad) {
        const p1 = evaluate(this.p1, valuation),
              p2 = evaluate(this.p2, valuation),
              rad = numeric.norm2Squared(numeric.sub(p2, p1))
        return Math.sqrt(rad)
      }
      const [p1, dp1] = evaluate(this.p1, valuation, true),
            [p2, dp2] = evaluate(this.p2, valuation, true),
            dpd = numeric.sub(dp2, dp1),
            pd = numeric.sub(p2, p1),
            rad = numeric.norm2Squared(pd),
            v = Math.sqrt(rad)
      // let xdn, ydn
      let dn
      if (v != 0) {
        dn = numeric.mul(1/v, pd)
      } else {
        const ang = Math.random() * Math.PI * 2
        dn = [ Math.cos(ang), Math.sin(ang) ]
        for (let i = 2; i < this.dim; i++) dn.push(Math.random() - 0.5)
      }
      return [v, numeric.dot(dn, dpd)]
    }
    // Dx1(d) where rad = sqrt((x1-x2)^2 + (y1-y2)^2) is (x1-x2)/rad * dx1
    //
    // d(ab) = a db + b da
    // d(ab)/da = b
    // d(ab)/db = a
    // dO/a = dO/d(ab) * d(ab)/da = dO/d(ab) * b

    backprop(task) {
        const p1 = this.p1.evaluate(task.valuation),
              p2 = this.p2.evaluate(task.valuation),
              pd = numeric.sub(p2, p1),
              sd = numeric.norm2Squared(pd),
              d = this.bpDiff
        let dn
        if (sd != 0) {
            const idist = d/Math.sqrt(sd)
            dn = numeric.mul(idist, pd)
        } else {
            // positions of points are considered arbitrary, so generate a
            // differential in a random direction.
            console.log("Warning: zero distance between points, generating force at random angle")

            const ang = Math.random() * Math.PI * 2
            dn = [ d * Math.cos(ang), d * Math.sin(ang) ]
            for (let i = 2; i < this.dim; i++) dn.push(d * (Math.random() - 0.5))
        }
        task.propagate(this.p1, numeric.neg(dn))
        task.propagate(this.p2, dn)
    }
    addDependencies(task) {
        task.prepareBackProp(this.p1)
        task.prepareBackProp(this.p2)
    }
    variables() {
        return exprVariables(this.p1).concat(exprVariables(this.p2))
    }
    toString() { return "distance(" + this.p1 + "," + this.p2 + ")" }
}

// A unary expression like -x
class UnaryExpression extends Expression {
    constructor(e) {
        super()
        this.expr = e
    }
    evaluate(valuation, doGrad) {
        if (!doGrad) return this.operation(evaluate(this.expr, valuation))
        const [a, da] = evaluate(this.expr, valuation, true)
        return this.gradop(a, da)
    }
    variables() {
        return exprVariables(this.expr)
    }
    addDependencies(task) {
        task.prepareBackProp(this.expr)
    }
}

// Expression for an absolute value |x|
class Abs extends UnaryExpression {
    constructor(e) { super(e) }
    operation(a) { return Math.abs(a) }
    gradop(a, da) {
        if (a > 0) return [a, da]
        return [-a, -da]
    }
    backprop(task) {
        const a = currentValue(this.expr),
              d = this.bpDiff
        if (a < 0) task.propagate(this.expr, -d)
        else task.propagate(this.expr, d)
    }
    toString() {
        return "Abs(" + this.expr + ")"
    }
}

// The expression -x
class Neg extends UnaryExpression {
    constructor(e) { super(e) }
    operation(a) { return -a }
    gradop(a, da) { return [-a, -da] }
    backprop(task) {
        task.propagate(this.expr, -this.bpDiff)
    }
}

// The square root operation
class Sqrt extends UnaryExpression {
    constructor(e) { super(e) }
    operation(a) { return Math.sqrt(a) }
    gradop(a, da) {
        if (a <= 0) return [0, getZeros(da.length)]
        const s = Math.sqrt(a)
        return [s, numeric.mul(0.5/s), da]
    }
    backprop(task) {
        let a = evaluate(this.expr, task.valuation)
        const d = this.bpDiff
        if (a <= 0) {
            // console.log("Trying to take the sqrt of a nonpositive number, generating random answer")
            a = Math.random()/1000 + 0.001
        }
        task.propagate(this.expr, d * 0.5/a)
    }
    toString() {
        return "Sqrt(" + this.expr + ")"
    }
}

// Squared L2 norm
class Sq extends UnaryExpression {
    constructor(e) { super(e) }
    operation(a) { return numeric.dot(a, a) }
    gradop(a, da) {
        return [numeric.dot(a, a), numeric.mul(2, a, da)]
    }
    backprop(task) {
        const a = currentValue(this.expr),
              d = this.bpDiff
        task.propagate(this.expr, numeric.mul(2, d, a))
    }
    toString() {
        return "Sq(" + this.expr + ")"
    }
}

// max(0,x)
class Relu extends UnaryExpression {
    constructor(e) { super(e) }
    operation(a) { if (a <= 0) return 0; else return a }
    gradop(a, da) { 
        if (a <= 0) return [0, getZeros(da.length)]
        return [a, da]
    }
    backprop(task) {
        const a = evaluate(this, task.valuation)
        if (a > 0) task.propagate(this.expr, this.bpDiff)
    }
    toString() { return "Relu(" + this.expr + ")" }
}

// A Conditional is an expression that evaluates to one expression if its condition is
// positive, and a second one otherwise.
class Conditional extends Expression {
    constructor(cond, epos, eneg) {
        super()
        this.cond = cond
        this.epos = epos
        this.eneg = eneg
    }
    evaluate(valuation, doGrad) {
        const cond = evaluate(this.cond, valuation, false)
        if (cond > 0) {
            return evaluate(this.epos, valuation, doGrad)
        } else {
            return evaluate(this.eneg, valuation, doGrad)
        }
    }
    addDependencies(task) {
        task.prepareBackProp(this.cond)
        task.prepareBackProp(this.epos)
        task.prepareBackProp(this.eneg)
    }
    initDiff() {
        this.bpDiff = 0
    }
    variables() {
        return exprVariables(this.cond)
               .concat(exprVariables(this.epos))
               .concat(exprVariables(this.eneg))
    }
    backprop(task) {
        const cond = this.cond.currentValue
        if (cond === undefined) console.error("undefined conditional guard ")
        if (cond > 0) {
            task.propagate(this.epos, this.bpDiff)
        } else {
            task.propagate(this.eneg, this.bpDiff)
        }
    }
    toString() {
        return "conditional(" + this.cond + "," + this.epos + "," + this.eneg + ")"
    }
}

// A fixed value between 0 and 1 representing the
// time during the current animation frame
class Time extends Expression {
    constructor(figure) {
        super()
        this.figure = figure
    }
    evaluate(valuation, doGrad) {
        const t = this.figure.animationTime
        return doGrad ? [t, getZeros(valuation.length)] : t
    }
    variables() { return [] }
    backprop(task) {}
    toString() {
        return "Time"
    }
}

// A Linear can interpolate, as a function of time, between two numbers or
// between any two expressions that evaluate to 1-D arrays, such as Points.
class Linear extends Expression {
    constructor(figure, frame, e1, e2) {
        super()
        this.figure = figure
        this.frame = frame
        this.e1 = e1
        this.e2 = e2
    }
    interp(t) { return t }
    evaluate(valuation, doGrad) {
        const figure = this.figure
        if (figure.currentFrame.isBefore(this.frame)) {
            return evaluate(this.e1, valuation, doGrad)
        }
        if (figure.currentFrame.isAfter(this.frame) && figure.currentFrame != this.frame) {
            return evaluate(this.e2, valuation, doGrad)
        }
    // const v = this.checkCache(valuation, doGrad)
    // if (v) return v
        const v1 = evaluate(this.e1, valuation, doGrad),
              v2 = evaluate(this.e2, valuation, doGrad),
              b = this.interp(this.figure.animationTime),
              a = 1 - b
        switch (doGrad ? typeof v1[0] : typeof v1) {
            case NUMBER:
                if (!doGrad) return v1 * a  + v2 * b
                return [ v1[0] * a + v2[0] * b,
                         numeric.add(numeric.mul(v1[1], a), numeric.mul(v2[1], b)) ]
            case OBJECT_STR:
                if (v1.constructor == Array) {
                    var result = new Array(v1.length)
                    for (let i = 0; i < v1.length; i++) {
                        result[i] = numeric.add(numeric.mul(v1[i], a), numeric.mul(v2[i], b))
                    }
                    // return this.recordCache(valuation, doGrad, result)
                    return result
                }
        }
        console.error("Don't know how to interpolate between " + v1 + " and " + v2)
    }
    x() { return new Projection(this, 0, 2) }
    y() { return new Projection(this, 1, 2) }

    backprop(task) {
      const b = this.interp(this.figure.animationTime), a = 1-b,
            figure = this.figure
      if (figure.currentFrame.isBefore(this.frame))
        task.propagate(this.e1, numeric.mul(a, this.bpDiff))
      if (figure.currentFrame.isAfter(this.frame))
        task.propagate(this.e2, numeric.mul(b, this.bpDiff))
    }
    addDependencies(task) {
        const figure = this.figure
        if (figure.currentFrame.isBefore(this.frame))
            task.prepareBackProp(this.e1)
        if (figure.currentFrame.isAfter(this.frame)) 
            task.prepareBackProp(this.e2)
    }
    toString() {
        return "Linear(" + this.e1 + "," + this.e2 + ")"
    }
}

// A cubic spline interpolator with slow out
// and slow in
class Smooth extends Linear {
    constructor(figure, frame, e1, e2) {
        super(figure, frame, e1, e2)
    }
    interp(t) { return cubicInterpWeight(t) }
    toString() {
        return "Smooth(" + this.e1 + "," + this.e2 + ")"
    }
}

function cubicInterpWeight(t) {
    return t*t*(3 - 2*t)
}

// A Projection can be used on an expression that returns an array. It
// picks out the value of the appropriate component of the array.
class Projection extends Expression {
    constructor(expr, index, n) {
        super()
        this.expr = expr
        this.index = index
        this.num = n
        if (index < 0 || index >= n) {
            console.error("Illegal index to Projection")
        }
    }
    evaluate(valuation, doGrad) {
        const v = evaluate(this.expr, valuation, doGrad), i = this.index
        if (doGrad) {
            const [x, dx] = v
            return [x[i], dx[i]]
        } else {
            if (v.constructor != Array)
                console.error("Projection expects its expression to have an array value: " + this.expr)
            if (i >= v.length)
                console.error("Attempt to project out a nonexistent element")
            return v[i]
        }
    }
    backprop(task) {
        const r = new Array(this.num).fill(0)
        r[this.index] = this.bpDiff
        task.propagate(this.expr, r)
    }
    addDependencies(task) {
        task.prepareBackProp(this.expr)
    }
    toString() { return "Projection(" + this.expr + "," + this.index + ")" }
    variables() {
        return exprVariables(this.expr)
    }
}

// A Temporal is an object that might only exist in some frames. It can be
// a GraphicalObject or a Constraint. By default an object exists and
// is visible in every frame.
//
class Temporal {
    constructor(figure) {
        this.figure = figure
    }
    active() { return true }

    // Is this object visible in frame f?
    visible() { return true }

    renderIfVisible() {
        if (this.visible(this.figure.currentFrame)) this.render()
    }
}

// A TemporalFilter contains a graphical object or a constraint.
class TemporalFilter extends Temporal {
    constructor(figure, obj) {
        super(figure)
        if (obj.constructor == Array) {
            console.error("Sorry, a Temporal can only hold one graphical object or one constraint. Use a Group or ConstraintGroup instead.")
        }
        if (!isFigure(figure)) {
            console.error("A Temporal must be constructed with a Figure")
        }
        this.obj = obj
        obj.installHolder(figure, this, obj) // tell the figure to install this object in the appropriate way
    }
    x() { return this.obj.x() }
    y() { return this.obj.y() }
    x0() { return this.obj.x0() }
    x1() { return this.obj.x1() }
    y0() { return this.obj.y0() }
    y1() { return this.obj.y1() }
    w() { return this.obj.w() }
    width() { return this.obj.width() }
    h() { return this.obj.h() }
    height() { return this.obj.height() }
    ul() { return this.obj.ul() }
    ll() { return this.obj.ll() }
    lr() { return this.obj.lr() }
    ur() { return this.obj.ur() }
    start() { return this.obj.start() }
    end() { return this.obj.end() }
    lc() { return this.obj.lc() }
    cr() { return this.obj.cr() }
    uc() { return this.obj.uc() }
    cl() { return this.obj.cl() }
    center() { return this.obj.center() }
    render() {
        this.obj.renderIfVisible()
    }
    getCost(valuation, doGrad) {
        if (this.active(this.figure.currentFrame)) {
            return this.obj.getCost(valuation, doGrad)
        } else {
            return zeroCost(valuation, doGrad)
        }
    }
    variables() {
        if (this.active(this.figure.currentFrame)) return this.obj.variables() 
        else return []
    }
    installHolder(figure, holder, child) {
        this.obj.installHolder(figure, holder, child)
    }
    bestMagnetPt(px, py, valuation) {
        return this.obj.bestMagnetPt(px, py, valuation)
    }
    backprop(valuation) { this.obj.backprop(valuation) }
    addToTask(task) { this.obj.addToTask(task) }
}

function zeroCost(valuation, doGrad) {
    return doGrad ? [0, getZeros(valuation.length)] : 0
}

// An After wraps another object and makes it exist only on and
// after the specified frame.
class After extends TemporalFilter {
    constructor(figure, frame, obj) {
        super(figure, obj)
        this.frame = frame
    }
    active() {
        return this.figure.currentFrame.isAfter(this.frame)
    }
}

// An After wraps another object and makes it appear only on and
// after the specified frame. However, it still exists for solving
// purposes.
class DrawAfter extends TemporalFilter {
    constructor(figure, frame, obj) {
        super(figure, obj)
        this.frame = frame
    }
    visible() {
        return this.figure.currentFrame.isAfter(this.frame)
    }
    addToTask(task) {
        this.obj.addToTask(task)
    }
}

// A Before wraps another object and makes it exist only before
// after the specified frame.
class Before extends TemporalFilter {
    constructor(figure, frame, obj) {
        super(figure, obj)
        this.frame = frame
    }
    active() {
        return !this.figure.currentFrame.isAfter(this.frame)
    }
}

// A Before wraps another object and makes it appear only before
// after the specified frame. However, it still exists for solving
// purposes.
class DrawBefore extends TemporalFilter {
    constructor(figure, frame, obj) {
        super(figure, obj)
        this.frame = frame
    }
    visible() {
        return !this.figure.currentFrame.isAfter(this.frame)
    }
}

// A Constraint has a cost that the system tries to minimize.
// A Constraint is associated with a Figure but might not be in
// its list of Constraints, because of ConstraintGroups.
class Constraint extends Temporal {

    // Create a constraint associated with figure.
    constructor(figure) {
        super(figure)
        if (!isFigure(figure)) {
            console.error("Constraints require an associated Figure")
            throw "no"
        }
        this.figure = figure
        figure.addConstraints(this)
    }
    getCost(valuation, doGrad) {
        console.error("No cost function defined for this constraint " + this)
        return zeroCost(valuation, doGrad)
    }
    addToTask(task) {
        console.error("No addToTask function defined for this constraint " + this.constructor)
        return
    }
    variables() { return [] }
    installHolder(figure, holder, child) {
        if (child.parent !== undefined) {
            console.error("Child Constraint already has a parent")
            return
        }
        child.parent = holder
        for (let i = 0; i < figure.Constraints.length; i++) {
            if (figure.Constraints[i] === child) {
                child.parent = holder
                break
            }
        }
        if (child.parent !== holder) {
            console.error("Child constraint not at top level")
        }
    }
    changeCost(cost) {
        this.cost *= cost
        return this
    }
}

// A Loss just directly expresses the cost that
// it will report. So it can report negative costs.
class Loss extends Constraint {
    constructor(figure, expr) {
        super(figure)
        this.expr = expr
        this.cost = 1
    }
    addToTask(task) {
        task.addTask(this.expr, this.cost)
    }
    getCost(valuation, doGrad) {
      if (!doGrad) {
        const v = evaluate(this.expr, valuation)
        return v * this.cost
      } else {
        const [x, dx] = evaluate(this.expr, valuation, true)
        return [x*this.cost, numeric.mul(dx, this.cost)]
      }
    }
    variables() {
        return exprVariables(this.expr)
    }
}

// A NearZero constraint tries to ensure that its expression is as close to
// zero as possible.
class NearZero extends Loss {
    constructor(figure, expr, cost) {
        super(figure, new Sq(expr))
        this.cost = cost || 1
    }
    toString() { return "0 ~ " + this.expr }
}

function constraintsCost(a, valuation, doGrad) {
    if (a.constructor !== Array) console.error("constraintsCost expects an array of constraints")
    if (a.length == 0) return zeroCost(valuation, doGrad)
    if (a.length == 1) return a[0].getCost(valuation, doGrad)
    if (!doGrad) {
        let cost = 0
        a.forEach(c => { cost += c.getCost(valuation, doGrad) })
        return cost
    } else {
        let cost = 0, dc = getZeros(valuation.length)
        a.forEach(c => {
            const [cc, cd] = c.getCost(valuation, true)
            cost += cc
            dc = numeric.add(dc, cd)
        })
        return [cost, dc]
    }
}

// A group of constraints that is treated as a single constraint.
class ConstraintGroup extends Constraint {
    constructor(figure, ...constraints) {
        super(figure)
        this.constraints = constraints.flat()
        this.constraints.forEach(c =>
            c.installHolder(figure, this, c)
        )
    }
    getCost(valuation, doGrad) {
        // constraint group doesn't have a cost of its own.
        if (doGrad) return [0, getZeros(valuation.length)]
        else return 0
        // return constraintsCost(this.constraints, valuation, doGrad)
    }
    variables() {
        let r = []
        this.constraints.forEach(c => {
            r = r.concat(c.variables())
        })
        return r
    }
    addToTask(task) {
        this.constraints.forEach(c => c.addToTask(task))
    }
}

// A LayoutObject does not support rendering and does not necessarily
// know what figure it is part of. Its size is 0 by default.
class LayoutObject extends Expression {
    constructor() { super() }
    toString() {
        return this.name ? this.constructor.name + " " + this.name : this.constructor.name
    }
    setName(name) {
        this.name = name
        return this
    }
    x0() { return new Minus(this.x(), new Times(this.w(), 0.5)) }
    x1() { return new Plus(this.x(), new Times(this.w(), 0.5)) }
    y0() { return new Minus(this.y(), new Times(this.h(), 0.5)) }
    y1() { return new Plus(this.y(), new Times(this.h(), 0.5)) }
    ul() { return new Point(this.x0(), this.y0()) }
    ur() { return new Point(this.x1(), this.y0()) }
    ll() { return new Point(this.x0(), this.y1()) }
    lr() { return new Point(this.x1(), this.y1()) }
    lc() { return new Point(this.x(), this.y1()) }
    cr() { return new Point(this.x1(), this.y()) }
    uc() { return new Point(this.x(), this.y0()) }
    cl() { return new Point(this.x0(), this.y()) }
    centerX() { return new Average(this.x0(), this.x1()) }
    centerY() { return new Average(this.y0(), this.y1()) }
    center() { return new Point(this.x(), this.y()) }
    width() { return this.w() }
    height() { return this.h() }
    w() { return 0 }
    h() { return 0 }
    variables() { return [] }
    connectionPts() {
        return [
                new Point(this.x(), this.y()),
                new Point(this.x1(), this.y()),
                new Point(this.x0(), this.y()),
                new Point(this.x(), this.y0()),
                new Point(this.x(), this.y1())
               ]
    }
    bestMagnetPt(px, py, valuation) {
        let [x,y] = evaluate([this.x(), this.y()], valuation)
        const scs = evaluate(this.connectionPts(), valuation),
              scdirs = scs.map(p => {
                                  const [sx,sy] = p,
                                        nm = norm2d(sx - x, sy - y)
                                  return nm == 0 ? [0,0] : [(sx - x)/nm, (sy - y)/nm]
                                })
        let pn = norm2d(px - x, py - y),
            pxn = (px-x)/pn, pyn = (py-y)/pn
        let best = scs[0], bd = scdirs[0][0] * pxn + scdirs[0][1] * pyn // cos of angle
        for (let i = 1; i < scs.length; i++) {
           const d = scdirs[i][0] * pxn + scdirs[i][1] * pyn
           if (d > bd) { bd = d; best = scs[i] }
        }
        return best
    }
    // Return the intersection of the line from (x,y) to to this
    // shape with the shape's boundary.
    intersectionPt(x, y, valuation) {
        let [xc, yc] = evaluate([this.x(), this.y()], valuation)
        let [x0, y0, x1, y1] = evaluate([this.x0(), this.y0(),
                                         this.x1(), this.y1()], valuation)
        if (Math.abs(x - xc) < TINY) {
            return [x, (y < yc) ? y0 : y1]
        }
        let slope = (y - yc)/(x - xc)
        let [xh, yh] = (x > xc)
            ? [x1, yc + slope * (x1 - xc)]
            : [x0, yc + slope * (x0 - xc)]
        if (yh < y1 && yh > y0) return [xh, yh]
        if (Math.abs(slope) < TINY) {
            return [ (x > xc) ? x1 : x0, y]
        }
        return (y > yc)
            ? [ xc + (y1 - yc)/slope, y1 ]
            : [ xc + (y0 - yc)/slope, y0 ]
    }

    // Return a range [x0, x1] that lies inside this object for the entirety of
    // the y range [y0, y1]. This is used to decide how to format text inside a shape.
    // Default is the full range [x0, x1]
    xSpan(y0, y1, valuation) {
        return evaluate([this.x0(), this.x1()], valuation)
    }
    render() {
        console.log("Attempted to render an object that has no rendering defined.")
    }
    variables() {
        return []
    }
    // Any LayoutObject can be used as an expression, in which case it represents
    // its (x,y) position. By default, LayoutObjects cache their results.
    evaluate(valuation, doGrad) {
      const v = this.checkCache(valuation, doGrad)
      if (v) return v
      if (!doGrad) {
            const x = evaluate(this.x(), valuation),
                  y = evaluate(this.y(), valuation)
            return this.recordCache(valuation, doGrad, [x, y])
      } else {
        const [x, dx] = evaluate(this.x(), valuation, true),
              [y, dy] = evaluate(this.y(), valuation, true)
        return this.recordCache(valuation, doGrad, [[x, y], [dx, dy]])
      }
    }
    backprop(task) {
        const d = this.bpDiff
        if (d.length != 2) {
            console.error("must backpropagate an (x,y) pair through a graphical object")
            return
        }
        task.propagate(this.x(), d[0])
        task.propagate(this.y(), d[1])
    }
    addDependencies(task) {
        task.prepareBackProp(this.x_)
        task.prepareBackProp(this.y_)
    }
    initDiff() {
        this.bpDiff = [0, 0]
    }

    toTop(v) {
        return new Point(this.x(), new Minus(this.y0(), legalExpr(v)))
    }
    toBottom(v) {
        return new Point(this.x(), new Plus(this.y1(), legalExpr(v)))
    }
    toLeft(v) {
        return new Point(new Minus(this.x0(), legalExpr(v)), this.y())
    }
    toRight(v) {
        return new Point(new Plus(this.x1(), legalExpr(v)), this.y())
    }
    inset(v) {
        v = legalExpr(v)
        const r = new GraphicalObject(this.figure)
        const me = this
        r.x = () => this.x()
        r.y = () => this.y()
        r.w = () => new Minus(this.w(), new Times(2, v))
        r.h = () => new Minus(this.h(), new Times(2, v))
        r.variables = () => me.variables().concat(exprVariables(v))
        return r
    }
    expand(v) {
        v = legalExpr(v)
        const r = new GraphicalObject(this.figure)
        const me = this
        r.x = () => this.x()
        r.y = () => this.y()
        r.w = () => new Plus(this.w(), new Times(2, v))
        r.h = () => new Plus(this.h(), new Times(2, v))
        r.variables = () => me.variables().concat(exprVariables(v))
        return r
    }
    // Builder to constrain both the x and y coordinates of a graphical object.
    // Arguments can be:
    //   x, y: the coordinates
    //   [x, y]: the coordinates
    //   a LayoutObject: coordinates are its x() and y()
    at() {
        if (arguments.length == 2) {
            this.figure.equal(this.x(), legalExpr(arguments[0]))
            this.figure.equal(this.y(), legalExpr(arguments[1]))
        } else if (arguments.length == 1) {
            const p = legalExpr(arguments[0])
            if (p.constructor == Array) {
                this.figure.equal(this.x(), p[0])
                this.figure.equal(this.y(), p[1])
            } else {
                this.figure.equal(this.x(), new Projection(p, 0, 2))
                this.figure.equal(this.y(), new Projection(p, 1, 2))
            }
        }
        return this
    }
}
Average.prototype.toTop = LayoutObject.prototype.toTop
Average.prototype.toLeft = LayoutObject.prototype.toLeft
Average.prototype.toBottom = LayoutObject.prototype.toBottom
Average.prototype.toRight = LayoutObject.prototype.toRight
Average.prototype.x0 = LayoutObject.prototype.x0
Average.prototype.x1 = LayoutObject.prototype.x1
Average.prototype.y0 = LayoutObject.prototype.y0
Average.prototype.y1 = LayoutObject.prototype.y1

// Check whether o can be used as a layout object and return it if so.
// Otherwise, log a suitable error message and return a legal layout object.
function legalLayoutObject(o) {
    if (o instanceof LayoutObject) return o
    if (o instanceof TemporalFilter) {
        const lo = legalLayoutObject(o.obj)
        return o
    }
    console.error("Not a legal graphical object: " + o)
    return new Point()
}

// A Box is a layout object with a width and height. It does not necessarily
// render but is useful for positioning other objects, because it can be used
// with functions that expect graphical objects, such as align().
class Box extends LayoutObject {
    constructor(figure, x_hint, y_hint, w_hint, h_hint) {
        super()
        this.figure = figure
        const prefix = this.toString() + "_"
        this.x_= new Variable(figure, prefix + "x", x_hint)
        this.y_ = new Variable(figure, prefix + "y", y_hint)
        this.w_ = new Variable(figure, prefix + "w", w_hint)
        this.h_ = new Variable(figure, prefix + "h", h_hint)
    }
    x() { return this.x_ }
    y() { return this.y_ }
    w() { return this.w_ }
    h() { return this.h_ }
    variables() {
        return [this.x(), this.y(), this.w(), this.h()]
    }
// convenience methods for positioning (by adding constraints)

    // Constrain the x coordinate of the object.
    setX(x) { this.figure.equal(this.x(), x); return this }
    // Constrain the y coordinate of the object.
    setY(y) { this.figure.equal(this.y(), y); return this }

    // Constrain the width of this object.
    setW(w) { this.figure.equal(this.w(), w); return this }
    // Constrain the height of this object.
    setH(h) { this.figure.equal(this.h(), h); return this }
}

// A GraphicalObject is centered at (x,y) and has a width w and height h.
// It also has some style attributes and it may contain text.
// LineWidth can be a constrained attribute too.
class GraphicalObject extends Box {
    constructor(figure, fillStyle, strokeStyle, lineWidth, x_hint, y_hint, w_hint, h_hint) {
        super(figure, x_hint, y_hint, w_hint, h_hint)

        figure.GraphicalObjects.push(this)

        this.fillStyle = fillStyle || figure.fillStyle
        this.strokeStyle = strokeStyle || figure.strokeStyle
        this.lineWidth = lineWidth || figure.lineWidth
        this.lineDash = figure.lineDash
    }
// builder methods for setting rendering style
    setFillStyle(s) {
        this.fillStyle = s
        return this
    }
    setStrokeStyle(s) {
        this.strokeStyle = s
        return this
    }
    setLineWidth(s) {
        this.lineWidth = legalExpr(s)
        return this
    }
    setLineDash(d) {
        this.lineDash = d
        return this
    }
    setOpacity(o) {
        this.opacity = o
        return this
    }
    // Fill the current graphics context appropriately based on the fill style and opacity
    fill() {
        const ctx = this.figure.ctx
        if (this.fillStyle) {
            ctx.fillStyle = this.fillStyle
            if (this.opacity) {
                ctx.globalAlpha = this.opacity
                ctx.fill()
                ctx.globalAlpha = 1
            } else {
                ctx.fill()
            }
        }
    }
// control contained text
    addText(...t) {
        this.text = new ContainedText(this.figure, createText(...t))
        return this
    }
    setTextStyle(s) {
        if (!this.text) console.error("This object does not contain text")
        this.text.setFillStyle(s)
        return this
    }
    setLayoutAlgorithm(a) {
        if (!this.text) console.error("This object does not contain text")
        this.text.setLayoutAlgorithm(a)
        return this
    }
    setJustification(j) {
        if (!this.text) console.error("This object does not contain text")
        this.text.setJustification(j)
        return this
    }
    setVerticalAlign(a) {
        if (!this.text) console.error("This object does not contain text")
        this.text.setVerticalAlign(a)
        return this
    }
    setLineSpacing(s) {
        if (!this.text) console.error("This object does not contain text")
        this.text.setLineSpacing(s)
        return this
    }
    setInset(ins) {
        if (!this.text) console.error("This object does not contain text")
        this.text.setInset(ins)
        return this
    }
    setFont(f) {
        if (!this.text) console.error("This object does not contain text")
        this.text.setFont(f)
        return this
    }
    // Set font size
    setFontSize(s) {
        if (!this.text) console.error("This object does not contain text")
        this.text.setFontSize(s)
        return this
    }
    // Set font name
    setFontName(f) {
        if (!this.text) console.error("This object does not contain text")
        this.text.setFontName(f)
        return this
    }
    // Set font style
    setFontStyle(s) {
        if (!this.text) console.error("This object does not contain text")
        this.text.setFontStyle(s)
        return this
    }
// rendering control
    active() { return true }
    visible() { return true }
    renderIfVisible() {
        if (this.visible(this.figure.currentFrame))
            this.render()
    }
    installHolder(figure, holder, child) {
        if (child.parent !== undefined) {
            console.error("Child GraphicalObject already has a parent")
            return
        }
        for (let i = 0; i < figure.GraphicalObjects.length; i++) {
            if (figure.GraphicalObjects[i] === child) {
                figure.GraphicalObjects[i] = holder
                child.parent = holder
                break
            }
        }
        if (child.parent !== holder) {
            console.error("Child object not in top-level list")
            figure.GraphicalObjects.push(holder)
        }
    }
}

// A Point acts like a graphical object wrt layout but does not generate new variables (unlike Box).
// It has no rendering, so it does not add itself to the graphical objects
// list. It also can act as an expression.
class Point extends LayoutObject {
    constructor(vx, vy) {
        super()
        if (vx === undefined)
            console.error("undefined Point x")
        if (vy === undefined)
            console.error("undefined Point y")
        this.x_ = vx
        this.y_ = vy
    }
    x() { return this.x_ }
    y() { return this.y_ }
    variables() {
        return exprVariables(this.x()).concat(exprVariables(this.y()))
    }
    toString() {
        return "Point(" + this.x_ + "," + this.y_ + ")"
    }
    at() {
        console.error("Sorry, Point.at() cannot be used because a Point does not know its Figure.")
        return this
    }
}

// A Group groups together a set of layout objects into a single object that
// is rendered together and whose location and bounds can be used to constrain
class Group extends GraphicalObject {
    constructor(figure, ...objects) {
        super(figure)
        this.objects = flattenGraphicalObjects(objects).map(o => legalLayoutObject(o))
        this.objects.forEach(o => { o.parent = this })
    }
    variables() {
        const result = [], g = this
        this.objects.forEach(o => {
            o.variables().forEach(v => {
                result.push(v)
            })
        })
        return result
    }
    x() { return this.centerX() }
    y() { return this.centerY() }
    x0() { return new Min(this.objects.map(o => o.x0())) }
    x1() { return new Max(this.objects.map(o => o.x1())) }
    y0() { return new Min(this.objects.map(o => o.y0())) }
    y1() { return new Max(this.objects.map(o => o.y1())) }
    w() { return new Minus(this.x1(), this.x0()) }
    h() { return new Minus(this.y1(), this.y0()) }
    render() {
        this.objects.forEach(o => o.renderIfVisible())
    }
    children() {
        return this.objects
    }
    align(horz, vert) {
        this.figure.align(horz, vert, ...this.objects)
        return this
    }
    setBounds(object) {
        this.x0 = () => object.x0()
        this.x1 = () => object.x1()
        this.y0 = () => object.y0()
        this.y1 = () => object.y1()
        return this
    }
}

// A TextFrame is a graphical object that doesn't have any rendering but does
// format contained text into a rectangular shape.
class TextFrame extends GraphicalObject {
    // text should be a ContainedText object
    constructor(figure, text, fillStyle) {
        super(figure, fillStyle)
        this.text = text
        figure.positive(this.h())
        figure.positive(this.w())
    }
    render() {
        if (this.text) {
            this.text.renderIn(this.figure, this)
        }
    }
}

// A filled rectangle. It can have text inside it.
class Rectangle extends GraphicalObject {
    constructor(figure, fillStyle, strokeStyle, lineWidth, x_hint, y, w_hint, h_hint) {
        super(figure, fillStyle, strokeStyle, lineWidth, x_hint, y, w_hint, h_hint)
        figure.positive(this.h())
        figure.positive(this.w())
        this.cornerRadius = 0
    }
    render() {
        const figure = this.figure, ctx = figure.ctx, valuation = figure.currentValuation
        ctx.save()
        const [x0, x1, y0, y1] = evaluate([this.x0(), this.x1(), this.y0(), this.y1()], valuation)
        ctx.translate(x0, y0)
        const w = x1-x0, h = y1-y0
        if (this.cornerRadius == 0) {
            ctx.beginPath()
            ctx.moveTo(0, 0)
            ctx.lineTo(w, 0)
            ctx.lineTo(w, h)
            ctx.lineTo(0, h)
            ctx.closePath()
        } else {
            Paths.roundedRect(ctx, 0, w, 0, h, this.cornerRadius)
        }
        ctx.lineWidth = evaluate(this.lineWidth, valuation)
        this.fill()
        if (this.strokeStyle != null) {
            ctx.strokeStyle = this.strokeStyle
            ctx.setLineDash(this.lineDash || [])
            ctx.stroke()
        }
        ctx.restore()
        if (this.text) {
            this.text.renderIn(this.figure, this)
        }
    }
    connectionPts() {
      if (this.cornerRadius == 0) {
        return [ this.ll(), this.lr(), this.ul(), this.ur(), this.cl(), this.cr(), this.uc(), this.lc() ]
      } else {
        const a = new Times(0.2929, this.cornerRadius)
        return [ this.cl(), this.cr(), this.uc(), this.lc(),
                    new Point(new Plus(this.x0(), a), new Plus(this.y0(), a)),
                    new Point(new Minus(this.x1(), a), new Plus(this.y0(), a)),
                    new Point(new Minus(this.x1(), a), new Minus(this.y1(), a)),
                    new Point(new Plus(this.x0(), a), new Minus(this.y1(), a)) ]
      }
    }
    setCornerRadius(r) {
        this.cornerRadius = legalExpr(r)
        return this
    }
}

// Some useful paths for rendering.
const Paths = {
    roundedRect: function (ctx, x0, x1, y0, y1, r) {
        const k = bezier_k
        ctx.beginPath()
        ctx.moveTo(x0+r, y0)
        ctx.lineTo(x1-r, y0)
        ctx.bezierCurveTo(x1-r+k*r, y0,  x1, y0+r-k*r,  x1, y0+r)
        ctx.lineTo(x1, y1-r)
        ctx.bezierCurveTo(x1, y1-r+k*r,  x1-r+k*r, y1,  x1-r, y1)
        ctx.lineTo(x0+r, y1)
        ctx.bezierCurveTo(x0+r-k*r, y1,  x0, y1-r+k*r, x0, y1-r)
        ctx.lineTo(x0, y0+r)
        ctx.bezierCurveTo(x0, y0+r-k*r,  x0+r-k*r, y0,  x0+r, y0)
        ctx.closePath()
    },
    roundedPolygon: function(ctx, r, pts) {
        ctx.beginPath()
        function arcPt(p1, p2) {
            const dx = p2[0]-p1[0],
                  dy = p2[1]-p1[1],
                  d2 = dx*dx + dy*dy,
                  d = Math.sqrt(d2)
            if (d <= TINY) return p1
            if (d < 2*r) {
                return [(p1[0] + p2[0])/2, (p1[1] + p2[1])/2]
            }
            const nr = r/d;
            return [p1[0] + dx*nr, p1[1] + dy*nr]
        }
        for (let i = 0; i < pts.length; i++) {
            const j = (i+1) % pts.length,
                  k = (i+2) % pts.length
            const p1 = arcPt(pts[i], pts[j]),
                  p2 = arcPt(pts[j], pts[i]),
                  p3 = arcPt(pts[j], pts[k])
            if (i == 0) {
                ctx.moveTo(p1[0], p1[1])
            } else {
                ctx.lineTo(p1[0], p1[1])
            }
            ctx.lineTo(p2[0], p2[1])
            ctx.bezierCurveTo((p2[0] + pts[j][0])/2, (p2[1] + pts[j][1])/2,
                              (p3[0] + pts[j][0])/2, (p3[1] + pts[j][1])/2,
                              p3[0], p3[1])
        }
        ctx.closePath()
    },
// Create an ellipse path with center (x,y) and x radius rx, y radius ry
    ellipse: function(ctx, x, y, rx, ry) {
        const k = bezier_k, rxk = rx * k, ryk = ry * k
        var x1 = x-rx, x2 = x-rxk, x3 = x+rxk, x4 = x+rx,
            y1 = y-ry, y2 = y-ryk, y3 = y+ryk, y4 = y+ry
        ctx.beginPath()
        ctx.moveTo(x4, y)
        ctx.bezierCurveTo(x4, y3,  x3, y4,  x, y4)
        ctx.bezierCurveTo(x2, y4,  x1, y3,  x1, y)
        ctx.bezierCurveTo(x1, y2,  x2, y1,  x, y1)
        ctx.bezierCurveTo(x3, y1,  x4, y2,  x4, y)
        ctx.closePath()
    },
    circle: function(ctx, x, y, r) {
        var rk = r*bezier_k, x1 = x-r, x2 = x-rk, x3 = x+rk, x4 = x+r,
                             y1 = y-r, y2 = y-rk, y3 = y+rk, y4 = y+r
    
        ctx.beginPath()
        ctx.moveTo(x4, y)
        ctx.bezierCurveTo(x4, y3,  x3, y4,  x, y4)
        ctx.bezierCurveTo(x2, y4,  x1, y3,  x1, y)
        ctx.bezierCurveTo(x1, y2,  x2, y1,  x, y1)
        ctx.bezierCurveTo(x3, y1,  x4, y2,  x4, y)
        ctx.closePath()
    },
    // Using ctx, create a path of cubic splines going through or near the
    // points in pts. Near the endpoints, it acts like a Bezier spline: the
    // curve goes through the first and last point and its initial and final
    // direction are toward the second and second-to-last points.
    bsplines: function(ctx, pts) {
        ctx.beginPath()
        ctx.moveTo(pts[0][0], pts[0][1])
        let n = pts.length
        switch(n) {
            case 1: ctx.stroke(); return
            case 2:
                ctx.lineTo(pts[1][0], pts[1][1])
                ctx.stroke()
                return
            case 4:
                ctx.bezierCurveTo(pts[1][0], pts[1][1],
                                pts[2][0], pts[2][1],
                                pts[3][0], pts[3][1])
                ctx.stroke()
                return
            default: break
        }
        const bk = bezier_k
        const k1 = 0.5*(1 - bk), k2 = 1 - k1
        for (let i = 0; i < n - 2; i++) {
            let p1=[], p2=[], p3=[]
            if (i == 0) {
                p1[0] = pts[i][0]*(1-bk) + pts[i+1][0]*bk
                p1[1] = pts[i][1]*(1-bk) + pts[i+1][1]*bk
            } else {
                p1[0] = pts[i][0]*k1 + pts[i+1][0]*k2
                p1[1] = pts[i][1]*k1 + pts[i+1][1]*k2
            }
            if (i == n-3) {
                p2[0] = pts[i+1][0]*bk + pts[i+2][0]*(1-bk)
                p2[1] = pts[i+1][1]*bk + pts[i+2][1]*(1-bk)
                p3 = pts[i+2]
            } else {
                p2[0] = pts[i+1][0]*k2 + pts[i+2][0]*k1
                p2[1] = pts[i+1][1]*k2 + pts[i+2][1]*k1

                p3[0] = pts[i+1][0]*bk + pts[i+2][0]*(1-bk)
                p3[1] = pts[i+1][1]*bk + pts[i+2][1]*(1-bk)
            }
            ctx.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1])
        }
    },
    // Using ctx, create a closed path of cubic splines going near the points in pts. 
    curve: function(ctx, pts) {
        ctx.beginPath()
        const n = pts.length,
              i0 = 0, i1 = 1,
              x0 = pts[0][0]*0.5 + pts[1][0]*0.5,
              y0 = pts[0][1]*0.5 + pts[1][1]*0.5
        ctx.moveTo(x0, y0)
        let p1=[], p2=[], p3=[]
        const k1 = 0.5*(1 - bezier_k), k2 = 1-k1
        for (let i = 0; i < n; i++) {
            let i0 = i, i1 = (i+1)%n, i2 = (i+2)%n

            p1[0] = pts[i0][0]*k1 + pts[i1][0]*k2
            p1[1] = pts[i0][1]*k1 + pts[i1][1]*k2
            p2[0] = pts[i1][0]*k2 + pts[i2][0]*k1
            p2[1] = pts[i1][1]*k2 + pts[i2][1]*k1
            p3[0] = pts[i1][0]*0.5 + pts[i2][0]*0.5
            p3[1] = pts[i1][1]*0.5 + pts[i2][1]*0.5
            ctx.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1])
        }
        ctx.closePath()
    }
}

class Square extends Rectangle {
    constructor(figure, fillStyle, strokeStyle, lineWidth, x_hint, y_hint, size_hint) {
        super(figure, fillStyle, strokeStyle, lineWidth, x_hint, y_hint, size_hint, size_hint)
        figure.equal(this.w(), this.h())
    }
}

class Ellipse extends GraphicalObject {
    constructor(figure, fillStyle, strokeStyle, lineWidth, x_hint, y_hint, size_hint) {
        super(figure, fillStyle, strokeStyle, lineWidth, x_hint, y_hint, size_hint, size_hint)
        figure.positive(this.h())
        figure.positive(this.w())
    }
    render() {
        const figure = this.figure, ctx = figure.ctx, valuation = figure.currentValuation
        ctx.save()
        const [x, y, w, h] = evaluate([this.x(), this.y(), this.w(), this.h()], valuation)
        ctx.translate(x - w/2, y - h/2)
        ctx.lineWidth = evaluate(this.lineWidth, valuation)
        Paths.ellipse(ctx, w/2, h/2, w/2, h/2)
        this.fill()
        if (this.strokeStyle != null) {
            ctx.strokeStyle = this.strokeStyle
            ctx.setLineDash(this.lineDash || [])
            ctx.stroke()
        }
        ctx.restore()
        if (this.text) {
            this.text.renderIn(this.figure, this)
        }
    }
    bestMagnetPt(px, py, valuation) {
        const x = evaluate(this.x(), valuation),
              y = evaluate(this.y(), valuation),
              pdx = px - x,
              pdy = py - y
        let xr = evaluate(this.w(), valuation)/2,
            yr = evaluate(this.h(), valuation)/2
        if (xr == 0 || yr == 0) return [x,y]
        const d = Math.sqrt(pdy*pdy*xr*xr + pdx*pdx*yr*yr)
        return [x + pdx*xr*yr/d, y + pdy*xr*yr/d]
    }
    intersectionPt(px, py, valuation) {
        return this.bestMagnetPt(px, py, valuation)
    }

    xSpan(y0, y1, valuation) {
        const [x,y,w,h] = evaluate([this.x(), this.y(), this.w(), this.h()], valuation)
        const y2 = Math.max(Math.abs(y - y0), Math.abs(y - y1))
        // equation: ((X - x)/(w/2))^2 + ((Y - y)/(h/2))^2 = 1
        const t = Math.min(1, 2*y2/h),
              d = 0.5 * w * Math.sqrt(1 - t*t)
        return [x - d, x + d]
    }
}

class Circle extends Ellipse {
    constructor(figure, fillStyle, strokeStyle, lineWidth, x_hint, y_hint, size_hint) {
        super(figure, fillStyle, strokeStyle, lineWidth, x_hint, y_hint, size_hint, size_hint)
        figure.equal(this.h(), this.w())
    }
    bestMagnetPt(px, py, valuation) {
        const x = evaluate(this.x(), valuation),
              y = evaluate(this.y(), valuation),
              r = evaluate(this.h(), valuation)/2,
              d = norm2d(px - x, py - y)
        if (d == 0) return [x,y]
        return [x + (px - x)*r/d, y + (py-y)*r/d]
    }
}

// A filled polygon. The vertices must be specified explicitly.
// polygon.points is an array of the points.
// Doesn't support cornerRadius yet.
//
class Polygon extends GraphicalObject {
    constructor(figure, points, fillStyle, strokeStyle, lineWidth) {
        super(figure, fillStyle, strokeStyle, lineWidth)
        points = flattenGraphicalObjects(points)
        this.points = points
        figure.equal(this.x1(), figure.max(points.map(p => p.x())))
        figure.equal(this.y1(), figure.max(points.map(p => p.y())))
        figure.equal(this.x0(), figure.min(points.map(p => p.x())))
        figure.equal(this.y0(), figure.min(points.map(p => p.y())))
    }
    render() {
        const figure = this.figure, ctx = figure.ctx, valuation = figure.currentValuation
        ctx.save()
        let pts = this.points.map(pt => evaluate(pt, valuation))
        const x0 = pts[0][0], y0 = pts[0][1]
        pts = pts.map(p => [p[0] - x0, p[1] - y0])
        ctx.translate(x0, y0)
        ctx.lineWidth = evaluate(this.lineWidth, valuation)
        ctx.lineDash = this.lineDash
        ctx.fillStyle = this.fillStyle
        if (this.cornerRadius) {
            Paths.roundedPolygon(ctx, this.cornerRadius, pts)
        } else {
            ctx.beginPath()
            for (let i = 0; i < this.points.length; i++) {
                const [x, y] = pts[i]
                if (i == 0) {
                    ctx.moveTo(x, y)
                } else {
                    ctx.lineTo(x, y)
                }
            }
            ctx.closePath()
        }
        this.fill()
        if (this.strokeStyle != null) {
            ctx.setLineDash(this.lineDash || [])
            ctx.strokeStyle = this.strokeStyle
            ctx.stroke()
        }
        ctx.restore()
        if (this.text) {
            this.text.renderIn(this.figure, this)
        }
    }
    setCornerRadius(r) {
        this.cornerRadius = legalExpr(r)
        return this
    }
    variables() {
        let result = GraphicalObject.prototype.variables.call(this)
        this.points.forEach(p => {
            result = result.concat(exprVariables(p))
        })
        return result
    }
}

class ClosedCurve extends Polygon {
    constructor(figure, points) {
        super(figure, points)
    }
    render() {
        const figure = this.figure, ctx = figure.ctx, valuation = figure.currentValuation
        ctx.save()
        const [x0, y0] = evaluate([this.x0(), this.y0()], valuation)
        ctx.translate(x0, y0)
        ctx.lineWidth = evaluate(this.lineWidth, valuation)
        ctx.lineDash = this.lineDash
        ctx.fillStyle = this.fillStyle
        const pts = []
        for (let i = 0; i < this.points.length; i++) {
            const [x, y] = evaluate(this.points[i], valuation)
            pts.push([x - x0, y - y0])
        }
        Paths.curve(ctx, pts)
        this.fill()
        if (this.strokeStyle != null) {
            ctx.setLineDash(this.lineDash || [])
            ctx.strokeStyle = this.strokeStyle
            ctx.stroke()
        }
        ctx.restore()
        if (this.text) {
            this.text.renderIn(this.figure, this)
        }
    }
}

function drawLineLabels(figure, pts, labels, startAdj, endAdj) {
    let ctx = figure.ctx,
        n = pts.length
    if (startAdj === undefined) startAdj = 0
    if (endAdj === undefined) endAdj = 0
    if (labels && labels.length > 0) {
      let total_d = -startAdj, cdists = [total_d], dists = []
      for (let i = 0; i < n - 1; i++) {
        let d = norm2d(pts[i+1][0] - pts[i][0],
                       pts[i+1][1] - pts[i][1])
        dists[i] = d
        total_d += d
        cdists[i+1] = total_d
      }
      if (startAdj) {
        dists[0] += startAdj
        total_d += startAdj
      }
      if (endAdj) {
        dists[n-2] += endAdj
        cdists[n-1] += endAdj
        total_d += endAdj
      }

      labels.forEach(linelabel => {
        let pos = evaluate(linelabel.position,
                              figure.currentValuation),
            offset = evaluate(linelabel.offset,
                              figure.currentValuation),
            dpos = pos * total_d
        let i = 0
        for (i = 0; i < n - 1; i++) {
            if (cdists[i+1] > dpos) break
        }
        let x1 = pts[i][0],
            y1 = pts[i][1],
            x2 = pts[i+1][0],
            y2 = pts[i+1][1],
            d = norm2d(x2-x1, y2-y1),
            dx = (x2 - x1)/d,
            dy = (y2 - y1)/d
        if (i == 0) {
            x1 -= startAdj * dx
            y1 -= startAdj * dy
            d += startAdj
        }
        if (i == n-2) {
            x2 += endAdj * dx
            y2 += endAdj * dy
            d += endAdj
        }
        let f = (dpos - cdists[i])/d,
            x = x1 + (x2 - x1) * f + dy * offset,
            y = y1 + (y2 - y1) * f - dx * offset
        linelabel.drawAt(ctx, x, y)
      })
    }
}

// Draw an arrowhead of size s in the current style,
// based at x0,y0 and heading toward x1, y1
function drawArrowhead(ctx, x0, y0, x1, y1, s) {
    const dx = x1 - x0, dy = y1 - y0
    ctx.save()
    ctx.translate(x1, y1)
    ctx.rotate(Math.atan2(dy, dx))

    ctx.beginPath()
    ctx.moveTo(0,0)
    ctx.lineTo(-s, -0.4 * s)
    ctx.lineTo(-s, 0.4 * s)
    ctx.closePath()
    ctx.fill()

    ctx.restore()
}

// Draw a curved arrowhead of size s in the current style,
// based at x0,y0 and heading toward x1, y1
function drawCurvedArrowhead(ctx, x0, y0, x1, y1, s) {
    const dx = x1 - x0, dy = y1 - y0
    ctx.save()
    ctx.translate(x1, y1)
    ctx.rotate(Math.atan2(dy, dx))

    ctx.beginPath()
    ctx.moveTo(0,0)
    ctx.bezierCurveTo(-0.5*s, -0.1*s, -0.5*s, -0.1*s, -s, -0.4 * s)
    ctx.lineTo(-s, 0.4 * s)
    ctx.bezierCurveTo(-0.5*s, 0.1*s, -0.5*s, 0.1*s, 0, 0)
    ctx.closePath()
    ctx.fill()

    ctx.restore()
}


// Bezier constant for a circular arc: (4/3) tan(theta/4)
function circularArcConstant(degrees) {
    return (4/3) * Math.tan(degrees * Math.PI / 180 / 4)
}

const bezier_k = circularArcConstant(90)

// Draw a circular "bullet" head of size s in the current style,
// based at x0,y0 and heading toward x1, y1
function drawBulletHead(ctx, x0, y0, x1, y1, s) {
    const dx = x1 - x0, dy = y1 - y0
    ctx.save()
    ctx.translate(x1, y1)
    ctx.rotate(Math.atan2(dy, dx))

    ctx.beginPath()
    ctx.moveTo(0,0)
    ctx.lineTo(-s, 0)
    ctx.stroke()
    Paths.circle(ctx, 0, 0, s/4)
    ctx.fill()
    ctx.restore()
}

const arrows = {
    arrow: drawArrowhead,
    bullet: drawBulletHead,
    curved: drawCurvedArrowhead,
}

// Draw an arrowhead for a line or curve endpoint at (x,y)
// where the previous point on the line or curve is at (x2, y2).
// Return the point where the line should extend from.
// If style is undefined, nothing is drawn and [x,y] is returned.
function drawLineEndSeg(ctx, style, size, x, y, x2, y2) {
    if (style === undefined) return [x,y]
    const xd = x - x2, yd = y - y2,
          d = norm2d(xd, yd)
    let cosa = 1, sina = 0
    if (Math.abs(d) > 1e-7) {
        cosa = xd/d; sina = yd/d
    }
    return drawLineEndDir(ctx, style, size, x, y, cosa, sina)
}

// Draw an arrowhead for a line or curve endpoint at (x,y)
// where the direction of the line is described by (cosa, sina).
// Return the point where the line should extend from.
// If style is undefined, nothing is drawn and [x,y] is returned.
function drawLineEndDir(ctx, style, size, x, y, cosa, sina) {
    if (style === undefined) return [x,y]
    let x1 = x - cosa * size,
        y1 = y - sina * size
    let arrowFun = arrows[style]
    if (arrowFun) arrowFun(ctx, x1, y1, x, y, size)
    return [x1, y1]
}

// A straight line
class Line extends GraphicalObject {
    // create a line from p1 to p2 (optionally specified)
    constructor(figure, strokeStyle, lineWidth, p1, p2) {
        super(figure, undefined, strokeStyle, lineWidth)
        this.p1 = p1 || new Point(figure.variable("p1x"), figure.variable("p1y"))
        this.p2 = p2 || new Point(figure.variable("p2x"), figure.variable("p2y"))
        this.startArrowStyle = undefined
        this.endArrowStyle = undefined
        this.arrowSize = Figure_defaults.ARROW_SIZE
    }
    // The starting point of the line
    start() {
        return this.p1
    }
    // The ending point of the line
    end() {
        return this.p2
    }
    render() {
        const figure = this.figure, ctx = figure.ctx, valuation = figure.currentValuation
        ctx.beginPath()
        ctx.strokeStyle = this.strokeStyle
        ctx.lineWidth = evaluate(this.lineWidth, valuation)
        const [x1, x2, y1, y2] = evaluate([this.p1.x(), this.p2.x(), this.p1.y(), this.p2.y()], valuation)
        const xd = x2 - x1, yd = y2 - y1,
                d = norm2d(xd, yd),
                cosa = xd/d, sina = yd/d
        if (this.fillstyle != null) ctx.fillStyle = this.fillStyle
        else ctx.fillStyle = this.strokeStyle
        ctx.setLineDash(this.lineDash || [])
        let [x1a, y1a] = drawLineEndDir(ctx, this.startArrowStyle, this.arrowSize, x1, y1, -cosa, -sina),
            [x2a, y2a] = drawLineEndDir(ctx, this.endArrowStyle, this.arrowSize, x2, y2, cosa, sina)

        ctx.beginPath()
        ctx.moveTo(x1a, y1a)
        ctx.lineTo(x2a, y2a)
        ctx.stroke()
    }
    setStartArrow(style) {
        this.startArrowStyle = style
        return this
    }
    setEndArrow(style) {
        this.endArrowStyle = style
        return this
    }
    setArrowSize(s) {
        this.arrowSize = s
        return this
    }
    setStart(p) {
        this.figure.pin(this.start(), p)
        return this
    }
    setEnd(p) {
        this.figure.pin(this.end(), p)
        return this
    }
    x0() {
        return new Min(this.p1.x(), this.p2.x())
    }
    x1() {
        return new Max(this.p1.x(), this.p2.x())
    }
    y0() {
        return new Min(this.p1.y(), this.p2.y())
    }
    y1() {
        return new Max(this.p1.y(), this.p2.y())
    }
    x() {
        return new Average(this.p1.x(), this.p2.x())
    }
    y() {
        return new Average(this.p1.y(), this.p2.y())
    }
    w() {
        return new Abs(new Minus(this.p2.x(), this.p1.x()))
    }
    h() {
        return new Abs(new Minus(this.p2.y(), this.p1.y()))
    }
    center() {
        return new Average(this.p1, this.p2)
    }
    variables() {
        return exprVariables(this.p1).concat(exprVariables(this.p2))
    }
}

// A horizontal line.
class HorzLine extends Line {
    constructor(figure, strokeStyle, lineWidth, p1, p2) {
        super(figure, strokeStyle, lineWidth, p1, p2)
        figure.equal(this.start().y(), this.end().y())
        // Need a stronger constraint to get the line oriented correctly
        figure.leq(this.start().x(), this.end().x())
    }
    x0() {
        return this.p1.x()
    }
    x1() {
        return this.p2.x()
    }
}

// A vertical line.
class VertLine extends Line {
    constructor(figure, strokeStyle, lineWidth, p1, p2) {
        super(figure, strokeStyle, lineWidth, p1, p2)
        figure.equal(this.start().x(), this.end().x())
        // Need a stronger constraint to get the line oriented correctly
        figure.leq(this.start().y(), this.end().y())
    }
    y0() {
        return this.p1.y()
    }
    y1() {
        return this.p2.y()
    }
}

function sqdist(xd, yd) { return xd*xd + yd*yd }
function norm2d(xd, yd) { return Math.sqrt(xd*xd + yd*yd) }

// The slice of the arguments starting from i as
// an array. Omit i to convert all.
function argsToArray(args, i) {
    var result = []
    if (i === undefined) i = 0
    while (i < args.length) result.push(args[i++])
    return result
}
// If args is an arguments object, call f() on each argument
// starting from index i.
function argsForEach(args, i, f) {
    while (i < args.length) {
        f(args[i++])
    }
}

function flattenGraphicalObjects(objects) {
    return objects.flat().filter(o => {
        if (!o.variables) {
            console.error("Not a graphical object: " + o)
            return false
        }
        return true
    })
}

// A Connector draws a curve from a first object to a last object, passing near 
// intermediate objects along the way. Bezier splines are used to connect objects.
class Connector extends GraphicalObject {
    constructor(figure, ...objects) {
        super(figure, undefined, figure.strokeStyle, figure.lineWidth)
        this.fillStyle = this.strokeStyle
        this.objects = flattenGraphicalObjects(objects)
        this.labels = []
        this.arrowSize = figure.arrowSize
        this.connectionStyle = figure.connectionStyle
    }
    setConnectionStyle(s) {
        switch(s) {
            case 'magnet':
            case 'intersection':
                this.connectionStyle = s
            default:
                console.error(`Illegal connection style: "${s}"`)
        }
        return this
    }
    render() {
        const figure = this.figure, ctx = figure.ctx, valuation = figure.currentValuation
        let objs = this.objects,
            i = 0, m = objs.length-1
        const pts = objs.map(o => 
            [ evaluate(o.x(), valuation),
              evaluate(o.y(), valuation) ]);

        switch (this.connectionStyle) {
            case 'magnet':
                [ pts[0][0], pts[0][1] ] = objs[0].bestMagnetPt(pts[1][0],
                                                    pts[1][1], valuation);
                [ pts[m][0], pts[m][1] ] = objs[m].bestMagnetPt(pts[m-1][0],
                                                    pts[m-1][1], valuation);
                break
            case 'intersection':
                [ pts[0][0], pts[0][1] ] = objs[0].intersectionPt(pts[1][0],
                                                    pts[1][1], valuation);
                [ pts[m][0], pts[m][1] ] = objs[m].intersectionPt(pts[m-1][0],
                                                    pts[m-1][1], valuation);
                break
        }
        ctx.strokeStyle = this.strokeStyle
        ctx.lineWidth = evaluate(this.lineWidth, valuation)
        ctx.setLineDash(this.lineDash || [])
        if (this.fillStyle) ctx.fillStyle = this.fillStyle
        if (this.startArrowStyle) {
            [pts[0][0], pts[0][1]] = 
                drawLineEndSeg(ctx, this.startArrowStyle, this.arrowSize,
                               pts[0][0], pts[0][1], pts[1][0], pts[1][1])
        }
        if (this.endArrowStyle) {
            [pts[m][0], pts[m][1]] = 
                drawLineEndSeg(ctx, this.endArrowStyle, this.arrowSize,
                               pts[m][0], pts[m][1], pts[m-1][0], pts[m-1][1])
        }

        ctx.strokeStyle = this.strokeStyle
        Paths.bsplines(ctx, pts)
        ctx.stroke()
        if (this.labels && this.labels.length > 0)
            drawLineLabels(figure, pts, this.labels, this.startArrowStyle ? this.arrowSize : 0,
                            this.endArrowStyle ? this.arrowSize : 0)
    }
    insert(object, pos) {
        objects = object.slice(0, pos).concat([object]).concat(object.slice(pos))
    }
    addLabel(obj) {
        this.labels.push(obj)
        return this
    }
    setStartArrow(style) {
        this.startArrowStyle = style
        return this
    }
    setEndArrow(style) {
        this.endArrowStyle = style
        return this
    }
    setArrowSize(s) {
        this.arrowSize = s
        return this
    }
    variables() {
        let r = []
        this.objects.forEach(o =>
            r = r.concat(exprVariables(o)))
        return r
    }
}

// Horizontal space.
class HSpace extends GraphicalObject {
    constructor(figure, w) {
        super(figure)
        if (w) figure.equal(this.w(), w)
    }
    render() {}
    renderIfVisible() {}
}

// Vertical space.
class VSpace extends GraphicalObject {
    constructor(figure, h) {
        super(figure)
        if (h) figure.equal(this.h(), h)
    }
    render() {}
    renderIfVisible() {}
}

class Font {
    constructor(figure) {
        if (!figure) {
            this.fontStyle = Figure_defaults.FONT_STYLE
            this.fontSize = Figure_defaults.FONT_SIZE
            this.fontName = Figure_defaults.FONT_NAME
        } else {
            this.copyFrom(figure.font)
        }
    }
    copy() {
        return new Font().copyFrom(this)
    }
    copyFrom(font) {
        if (font.fontName) this.fontName = font.fontName
        if (font.fontStyle) this.fontStyle = font.fontStyle
        if (font.fontObj) this.fontObj - font.fontObj
        this.fontSize = font.fontSize
        return this
    }
    setFontObject(font, size) {
        this.fontObj = font
        this.fontSize = size
        return this
    }
    setName(name) {
        this.fontName = name
        this.fontObj = null
        return this
    }
    getName() {
        return this.fontName
    }
    setSize(s) {
        this.fontSize = s
        this.fontObj = null
        return this
    }
    getSize() {
        return this.fontSize
    }
    setStyle(style) {
        this.fontStyle = style
        this.fontObj = null
        return this
    }
    setContextFont(context) {
        if (this.fontObj) {
            context.font = this.fontObj
        } else {
            const f = (this.fontStyle ? this.fontStyle + " " : "")
                        + this.fontSize + "px " + this.fontName
            context.font = f
        }
    }
}

// Measure the 'cost' of a successful text layout ly that starts from position x on the first line.
// Lower costs are better. Note that the last line does not have any cost.
function layoutCost(ly, x) {
    let cost = 0
    const lines = ly.lines, n = lines.length
    for (let i = 1; i < n; i++) {
        const line = lines[i],
              items = line.items,
              m = items.length
        const left = (i == n-1) ? x : line.x0
        let span = line.x1 - left
        for (let j = 0; j < m; j++) {
            const item = items[j]
            span -= item.width
            if (item.item && item.item.cost) cost += item.item.cost
        }
        cost += span * span * span
    }
    return cost
}

function spaces(n) {
    let result = "";
    while (n > 0) {
        result += "  ";
        n--;
    }
    return result;
}

// Whether ly1 is a better layout than ly2. Both layouts start from x on the first line.
// Successful layouts always beat unsuccessful ones. Successful layouts are compared using
// layout cost. Unsuccessful layouts are compared based on how much of the text was laid out.
function lowerCost(ly1, ly2, x) {
    if (ly1.success) {
        if (!ly2.success) return true;
        return (layoutCost(ly1, x) < layoutCost(ly2, x));
    }
    if (ly2.success) return false;
    return countItems(ly1) > countItems(ly2);
}

// Find a layout for the given sequence of items in context, within the container,
// starting from position (x, y) and not exceeding ymax, and assuming that the
// line that position is on extends from x0 to x1. The input sequence
// citems is an array of objects ("context-items") in reverse order, each
// with the following structure:
//    {
//       item: the text item 
//       context: the context of the item (TextContext)
//    }
// Only the first n items in citems are to be laid out.
// 
// The result is an object with two fields:
//  {
//     success: a boolean indicating whether layout was completed
//     lines: an array each of whose elements describe one formatted line. The
//            elements appear in *reverse order*.
//            In the case where success is false, lines contains an incomplete
//            layout.
//  }
// A lines array element is an object with
// the following properties:
// { x0:    the left margin of the line
//   x1:    the right margin of the line
//   y:     the vertical position of the baseline
//   items: an array of "renderable" items as defined in TextItem.layout. The items
//          are in *reverse order*
// }
function findLayout(figure, citems, n, x, y, x0, x1, ymax) {
    if (n == 0) {
        return {
            success: true,
            lines: [{ x0, x1, y, items: []}]
        }
    }
    const citem = citems[n-1],
          item = citem.item,
          tc = citem.context, // XXX
          ls = tc.get("lineSpacing"), 
          res0 = item.layout(figure, tc, x, y, x0, x1, ymax)
    if (!res0.success || res0.positions.length == 0) {
        return {
            success: false,
            lines: [{ x0, x1, y, items: []}]
        }
    }
    const posns = res0.positions
    n--
    let best = undefined, bestp = undefined
    if (res0.following.length > 0) {
        citems = citems.slice(0, n)
        const newItems = res0.following.reverse()
        for (let i=0; i < newItems.length; i++) {
            citems.push(newItems[i])
            n++
        }
    }
    const greedy = tc.get("layoutAlgorithm") == "greedy"
    function checkIfBest(posn) {
        let rest
        if (posn.newLine) {
            const inset = tc.get("inset"), container = tc.get("container")
            let [nx0, nx1] = container.xSpan(y, y + ls, figure.currentValuation)
            nx0 += inset
            nx1 -= inset
            rest = findLayout(figure, citems, n, nx0, y + ls, nx0, nx1, ymax)
            rest.lines.push({x0, x1, y, items: []})
        } else {
            rest = findLayout(figure, citems, n, posn.x, y, x0, x1, ymax)
        }
        const renderable = posn.renderable, lines = rest.lines
        if (renderable) lines[lines.length - 1].items.push(renderable)
        if (best === undefined || lowerCost(rest, best, x)) {
            best = rest
            bestp = posn
        }
    }
    let key, cache
    if (posns.length > 1) {
        // key = `${x},${y}`
        key = x + y * 1009
        cache = item.cache
        if (!cache) item.cache = cache = new Map()
        const memoized = cache.get(key)
        if (memoized !== undefined) {
            checkIfBest(memoized)
            return best
        }
    }
    for (let i = 0; i < posns.length; i++) {
        const posn = posns[i]
        checkIfBest(posn)
        if (greedy && best !== undefined && best.success) break
    }
    if (key !== undefined) cache.set(key, bestp)
    return best
}

// A label.
class Label extends GraphicalObject {
    constructor(figure, text, fontSize, fontName, fillStyle, x, y) {
        super(figure, fillStyle, undefined, 1, x, y)
        if (text.layout) {
            this.text = new ContainedText(figure, text) // either a String or a TextItem
            this.font = new Font(figure)
            if (fillStyle != null) {
                this.fillStyle = this.text.fillStyle = fillStyle
            } else {
                this.fillStyle = figure.textStyle
            }
        } else {
            this.text = text
            this.font = new Font(figure)
            if (fillStyle != undefined) this.fillStyle = fillStyle
            else this.fillStyle = figure.textStyle
        }
        if (fontSize) this.font.setSize(fontSize)
        if (fontName) this.font.setName(fontName)

        this.setStrokeStyle(undefined)
        this.computeWidth(figure.ctx)

        // Have to override GraphicalObject in the object itself
        this.w = function() { return this.computedWidth }
        this.h = function() { return this.font.getSize() }
        this.variables = function() { return [this.x(), this.y()] }
    }
    setFont(font) {
        this.font = font
        this.computeWidth(this.figure.ctx)
        return this
    }
    installFont() {
        this.font.setContextFont(this.figure.ctx)
    }
    render() {
        const figure = this.figure, ctx = figure.ctx, valuation = figure.currentValuation
        this.installFont()
        const x = evaluate(this.x0(), valuation),
              y = evaluate(figure.average(this.y(), this.y1()), valuation)
        if (this.text.constructor == String) {
            if (this.fillStyle) {
                ctx.fillStyle = this.fillStyle
                ctx.fillText(this.text, x, y)
            }
            if (this.strokeStyle != null) {
                ctx.strokeStyle = this.strokeStyle
                if (this.lineWidth) {
                    ctx.lineWidth = evaluate(this.lineWidth, valuation)
                }
                ctx.strokeText(this.text, x, y)
            }
        } else {
            const tc = new TextContext(null, figure)
            tc.setAll({font: this.font, verticalAlign: "center",
              justification: "center", lineSpacing: 0, inset: 0,
              layoutAlgorithm: "greedy", baseline: 0,
              fillStyle: this.fillStyle, strokeStyle: null,
              container: this
            })
            const layout = findLayout(figure, [{item: this.text.text, context: tc}], 1,
                                       x, y, x, Figure_defaults.LARGE_SPAN, y)
            let w = 0, items = layout.lines[0].items.reverse()
            for (let i = 0; i < items.length; i++) {
                const item = items[i]
                if (item.font) item.font.setContextFont(ctx)
                if (item.item) item.item.render(ctx, x + w, item.y)
                w += item.width
            }
        }
    }
    // A label will stretch as far as necessary to fit its text
    xSpan(y0, y1, valuation) {
        return [0, Figure_defaults.LARGE_SPAN]
    }
    computeWidth(ctx) {
        this.installFont()
        if (this.text.constructor == String) {
            this.computedWidth = ctx.measureText(this.text).width
        } else {
            const tc = new TextContext(null, figure)
            tc.setAll({font: this.font, verticalAlign: "center",
              justification: "center", lineSpacing: 0, inset: 0,
              layoutAlgorithm: "greedy",
              fillStyle: this.fillStyle,
              strokeStyle: null, baseline: 0,
              forceLayout: false, container: this
            })
            const layout = findLayout(this.figure, [{item: this.text.text, context: tc}], 1,
                                      0, 0, 0, Figure_defaults.LARGE_SPAN, 0)

            if (!layout.success) {
                console.error("Could not lay out a label")
                return 0
            }
            let w = 0, items = layout.lines[0].items
            for (let i = 0; i < items.length; i++) {
                const item = items[i]
                w += item.width
            }
            this.computedWidth = w
        }
    }

    // Set font size
    setFontSize(s) {
        this.font.setSize(s)
        this.computeWidth(this.figure.ctx)
        return this
    }

    // Set font name
    setFontName(n) {
        this.font.setName(n)
        return this
    }

    // Set font style
    setFontStyle(n) {
        this.font.setStyle(n)
        return this
    }
}

// A label somewhere along a connector.
// By default the label is simply text, but
// overriding the drawAt method allows rendering
// other graphics along the connector.
// position: fractional position along connector.
// offset: (optional) offset toward the port side of
// the connector.
class LineLabel {
    constructor(figure, text, position, offset) {
        this.text = text
        this.position = position
        this.offset = offset || figure.font.getSize()
        this.strokeStyle = figure.strokeStyle
        this.fillStyle = figure.textStyle || "#000000"
        this.font = new Font(figure)
    }
    drawAt(ctx, x, y) {
        this.font.setContextFont(ctx)
        ctx.fillStyle = this.fillStyle
        x -= ctx.measureText(this.text).width / 2
        y += this.font.getSize()/2
        ctx.fillText(this.text, x, y)
    }
    setFillStyle(s) { this.fillStyle = s; return this }
    setStrokeStyle(s) { this.strokeStyle = s; return this }
    setFontName(n) { this.font.setName(n); return this }
    setFontSize(s) { this.font.setSize(s); return this }
}

function countItems(ly) {
    let c = 0
    const lines = ly.lines, nlines = lines.length
    for (let i = 0; i < nlines; i++) {
        c += lines[i].items.length
    }
    return c
}

// A ContainedText holds some text that can be formatted inside
// a graphical object. It is not a graphical object itself;
// it serves as the glue between a graphical object and the text
// it contains. It knows how to format the text and to render it
// into the containing shape. It has methods to control the presentation
// style (e.g., inset and centering) and the default style of the text it
// contains.
// 
class ContainedText {
    constructor(figure, ...text) {
        this.figure = figure
        this.justification = "center"
        this.verticalAlign = "center"
        this.lineSpacing = figure.lineSpacing
        this.font = figure.getFont()
        this.fillStyle = figure.strokeStyle
        this.strokeStyle = null
        this.inset = this.font.getSize() / 3
        this.text = createText(...text)
    }
    setLineSpacing(s) {
        this.lineSpacing = s
        return this
    }
    setInset(ins) {
        this.inset = ins
        return this
    }
    // justification can be "left", "center" (default), or "full"
    setJustification(j) {
        this.justification = j
        return this
    }
    // can be "top", "center" (default), or "bottom"
    setVerticalAlign(va) {
        this.verticalAlign = va
        return this
    }
    setFont(f) {
        this.font = f
        return this
    }
    // Set font size
    setFontSize(s) {
        this.font.setSize(s)
        return this
    }
    // Set font name
    setFontName(f) {
        this.font.setName(f)
        return this
    }
    // Set font style
    setFontStyle(s) {
        this.font.setStyle(s)
        return this
    }
    setFillStyle(s) {
        this.fillStyle = s
        return this
    }
    setLayoutAlgorithm(a) {
        this.layoutAlgorithm = a
        return this
    }

    // Draw this text inside a graphical object (container)
    renderIn(figure, container) {
        const ctx = figure.ctx,
              valuation = figure.currentValuation,
              font = this.font,
              lineSpacing = evaluate(this.lineSpacing, valuation) * font.getSize(),
              layoutAlgorithm = this.layoutAlgorithm || "TeX",
              baseline = 0,
              strokeStyle = this.strokeStyle || null,
              maxh = evaluate(container.h(), valuation),
              inset = this.inset,
              justification = this.justification,
              verticalAlign = this.verticalAlign,
              fillStyle = this.fillStyle,
              tc = new TextContext(null, figure),
              y0 = evaluate(container.y0(), valuation) + font.getSize() + inset,
              y1 = evaluate(container.y1(), valuation) - inset,
              yc = evaluate(container.y(), valuation)
        let layout = {success: false, lines: []}
        tc.setAll({ font, verticalAlign, justification, fillStyle, lineSpacing, inset,
                    layoutAlgorithm, strokeStyle, baseline, container })
        this.text.resetCaches()
        let guessed_lines = 1,
            y = y0,
            max_guessed_lines = Math.floor(maxh/lineSpacing)
        if (this.verticalAlign == "top") guessed_lines = max_guessed_lines

        if (DEBUG) console.log("max guessed lines = " + max_guessed_lines)

        // Compute the successful layout with the least guessed lines, or the largest
        // unsuccessful layout.
        let x0 = 0, x1 = 0, tries = 0
        for (; guessed_lines <= max_guessed_lines; guessed_lines++, tries++) {
            let ymax = y1
            switch (this.verticalAlign) {
                case "center":
                    y = yc - (guessed_lines - 1.5) * lineSpacing * 0.5
                    ymax = y + (guessed_lines - 0.25) * lineSpacing
                    break
                case "bottom":
                    y = y1 - (guessed_lines - 0.75) * lineSpacing
                    break
                default: break
            }
            [x0, x1] = container.xSpan(y - lineSpacing, y, valuation)
            x0 += inset
            x1 -= inset
            const ly = findLayout(figure, [{ item: this.text, context: tc }], 1,
                                  x0, y, x0, x1, ymax)
            if (ly.success) {
                layout = ly
                if (DEBUG) console.log("found best layout at " + guessed_lines)
                break
            }
            if (!ly.success && this.verticalAlign == "top" && countItems(ly) == 0) {
                guessed_lines--
                y = y0 + tries
                if (y > ymax) break
            }
            if (countItems(ly) > countItems(layout)) layout = ly
        }

        if (!layout.success) {
            // console.log("Could not lay out text items in container " + container)
        }

        // Use the computed layout to horizontally position all the items
        // according to the current justification policy, and draw them.
        let currentFont = null, stretch = (justification == "full")
        const lines = layout.lines.reverse(), last = lines[lines.length - 1]
        for (let line of lines) {
            const {x0, x1, y, items} = line
            let items_rev = items.reverse()
            let lw = 0, stretchers = 0
            for (let i = 0; i < items_rev.length; i++) {
                const item = items_rev[i]
                lw += item.width
                stretchers += item.stretch
            }
            let extra = x1 - x0 - lw
            let x = x0
            switch (justification) {
                case "left":
                case "full": x = x0; break
                case "center": x = x0 + extra/2; break
                case "right": x = x0 + extra; break
            }
            for (let i = 0; i < items_rev.length; i++) {
                const item = items_rev[i],
                      font = item.font
                if (font && font != currentFont) {
                    font.setContextFont(ctx)
                    currentFont = font
                }
                if (item.item) {
                    if (item.fillStyle != null) ctx.fillStyle = item.fillStyle
                    if (item.strokeStyle != null) ctx.strokeStyle = item.strokeStyle
                    item.item.render(ctx, x, item.y)
                }
                if (stretch && stretchers > 0 && line !== last) {
                    x += (extra * item.stretch)/stretchers
                }
                x += item.width
            }
        }
    }

}

// A component of formatted text. It does not know what figure or container it belongs to.
class TextItem {
    constructor() {
    }

    // TextItem.layout tries to format this text item into the container
    // starting from baseline position (x,y) but without extending below y position
    // ymax, and with x1 as the right margin of the current line.  The result
    // is an object with these fields:
    //  {
    //     success: a boolean indicating whether layout was completed
    //     positions: an array of positions at which formatting can continue
    //           after this item. For most text items, this is a single-element array, but
    //           breakable whitespace may return two positions. If success is false, this
    //           property is left undefined. A position has the following properties:
    //           {
    //              newLine: boolean; whether the next position is on the next line. In this
    //                 case there will be no x position
    //              x: the x position at which to start formatting the next context-item on the same line
    //                 (this property is undefined if newLine is true)
    //              renderable: an item appearing on the line (possibly undefined if nothing
    //                 to render or lay out or if success is false) with the following properties:
    //                   { item: the actual text item to render (may be null for non-rendered items)
    //                     y: vertical position of the item
    //                     width: the minimum width of this item
    //                     stretch: the amount of stretchiness (typically 0 for non-whitespace)
    //                     font: the font
    //                     fillStyle: the fill style
    //                     strokeStyle: the stroke style (if any)
    //                   }
    //     following: an array of context-items (see findLayout) that should be
    //                formatted after this one, or undefined if success is false.
    //                Elements are in forward order.
    //  }
    layout(figure, textContext, x, y, x0, x1, ymax) {
        return {success: false}
    }

    // Render this text item at (x,y) in graphics context ctx.  The font, fill
    // style, and stroke style are assumed already to be set correctly.
    // Default: do nothing
    render(ctx, x, y) {}

    // Erase any cached information specific to a given layout task
    resetCaches() {}
    toString() { return "[TextItem]" }
}

function createText(...text) {
    text = text.flat()
    const result = []
    text.forEach(t => {
        if (t.constructor == String) { 
            let lines = 0
            t.split(/\n/).forEach(ln => {
                let wds = 0
                if (lines++) {
                    result.push(new LineBreak())
                }
                ln.split(/  */).forEach(w => {
                    if (w) {
                        if (wds++) {
                            result.push(new Whitespace())
                        }
                        let parts = 0
                        w.split(//).forEach(part => {
                            if (parts++) result.push(new Hyphen())
                            result.push(new WordText(part))
                        })
                    }
                })
            })
        } else {
            result.push(t)
            if (!t.layout) console.error("Can't concatenate non-text item")
        }
    })
    if (result.length == 0) return new WordText("")
    else if (result.length == 1) return result[0]
    else return new ConcatText(...result)
}

//  A context for rendering and laying out text items, to be provided at the point
//  of rendering. The context is updated imperatively, but it inherits properties
//  from its parent, so any changes made to it do not affect the parent.
class TextContext {
    // Create a text context that inherits from parent
    constructor(parent, figure) {
        this.properties = new Map()
        this.figure = figure
        this.parent = parent
    }
    set(name, value) {
        this.properties.set(name, value)
        return this
    }
    setAll(dict) {
        for (let key in dict) {
            this.set(key, dict[key])
        }
        return this
    }
    get(name) {
        const key = name,
              properties = this.properties,
              val = properties.get(key)
        if (val !== undefined) return val
        if (this.parent) {
            const v2 = this.parent.get(name)
            properties.set(key, v2)
            return v2
        }
        console.error("Requested undefined text context attribute " + name)
        return undefined
    }
}

// A text item that consists of a simple string that should not be broken.
class WordText extends TextItem {
    constructor(t) {
        super()
        this.text = t
    }
    toString() { return `[WordText ${this.text}]` }

    // See TextItem.layout
    layout(figure, tc, x, y, x0, x1, ymax) {
        const ctx = figure.ctx,
              font = tc.get("font")
        let width = this.width
        if (!width) {
            font.setContextFont(ctx)
            this.width = width = ctx.measureText(this.text).width
        }
        if (x + width > x1) {
            return { success: false }
        }
        let renderable = {
          item: this,
          y: y - tc.get("baseline"),
          width,
          stretch: 0, 
          font,
          fillStyle: tc.get("fillStyle"),
          // strokeStyle: tc.get("strokeStyle"),
        }

        return { success: true,
                 positions: [{ newLine: false, x: x + width, renderable }],
                 following: []
               }
    }
    render(ctx, x, y) {
        ctx.fillText(this.text, x, y)
    }
    resetCaches() {
        delete this.width 
    }
}

var ws_counter = 0

var EMPTY_IMMUTABLE_ARRAY = []

class Whitespace extends TextItem {
    constructor(figure) {
        super(figure)
        this.index = ws_counter++
    }
    toString() { return `[Whitespace ${this.index}]` }
    // See TextItem.layout
    layout(figure, tc, x, y, x0, x1, ymax) {
        let space = this.width
        if (!space) {
              const font = tc.get("font")
              font.setContextFont(figure.ctx)
              space = figure.ctx.measureText(" ").width
              this.width = space
        }
        const positions = []
        if (x + space <= x1) {
            positions.push( { newLine: false,
                              x: x + space,
                              renderable: {
                                item: null,
                                width: space,
                                stretch: 1
                              }
                            } )
        }
        const ls = tc.get("lineSpacing")
        if (y + ls <= ymax) {
            positions.push({
                newLine: true
            })
        }
        return {
            success: positions.length > 0,
            positions,
            following: []
        }
    }
    resetCaches() {
        delete this.width 
        delete this.cache
    }
}

class ConcatText extends TextItem {
    // The arguments (other than the figure) can be either other ContainedText
    // objects or strings. Strings are automatically split into words
    // around whitespace
    constructor(...text) {
        super()
        this.items = text
    }
    toString() { return "[ConcatText]" }
    // See TextItem.layout
    layout(figure, tc, x, y, x0, x1, ymax) {
        return {
            success: true,
            positions: [{newLine: false, x}],
            following: this.items.map(item => ({item, context: tc}))
        }
    }
    resetCaches() {
        for (let item of this.items) item.resetCaches();
    }
}

class Hyphen extends TextItem {
    constructor() {
        super()
        this.cost = Figure_defaults.HYPHEN_COST
    }
    toString() { return "[Hyphen]" }
    // See TextItem.layout
    layout(figure, tc, x, y, x0, x1, ymax) {
        let width = this.width
        if (!width) {
              const font = tc.get("font")
              font.setContextFont(figure.ctx)
              width = figure.ctx.measureText("-").width
              this.width = width
        }
        const positions = [{ newLine: false, x }]
        const ls = tc.get("lineSpacing")
        if (x + width <= x1 && y + ls <= ymax) {
            positions.push( { newLine: true,
                              renderable: {
                                 item: this,
                                 y,
                                 width,
                                 stretch: 0
                              }
                            } )
        }
        return {
            success: true,
            positions,
            following: []
        }
    }
    render(ctx, x, y) {
        ctx.fillText("-", x, y)
    }
}

class LineBreak extends TextItem {
    constructor() {
        super()
        this.cost = Figure_defaults.HYPHEN_COST
    }
    toString() { return "[LineBreak]" }
    // See TextItem.layout
    layout(figure, tc, x, y, x0, x1, ymax) {
        const positions = []
        const ls = tc.get("lineSpacing")
        if (y + ls <= ymax) {
            positions.push( { newLine: true } )
        }
        return {
            success: true,
            positions,
            following: []
        }
    }
    render(ctx, x, y) {
        ctx.fillText("-", x, y)
    }
}

// A ContextTransformer wraps some text in a context that is modified in
// some way to change how the text appears.
class ContextTransformer extends TextItem {
    // Create a ContextTransformer that wraps the text
    // and transforms the outer context tc into f(tc).
    constructor(f, text) {
        super()
        this.text = (text.constructor == String) ? new WordText(text) : text
        this.fun = f
    }
    // See TextItem.layout
    layout(figure, tc, x, y, x0, x1, ymax) {
        tc = this.transformContext(tc, figure)
        return this.text.layout(figure, tc, x, y, x0, x1, ymax)
    }
    // Transform the outside context in some way. Default
    // implementation: do nothing to context.
    transformContext(tc, figure) {
        let tc2 = new TextContext(tc, figure)
        return this.fun(tc2)
    }
    resetCaches() {
        this.text.resetCaches()
    }
}

class SuperscriptText extends ContextTransformer {
    constructor(text) { super(null, text) }
    transformContext(tc, figure) {
        const baseline = tc.get("baseline"), font = tc.get("font"),
              fontSize = font.getSize()
        tc = new TextContext(tc, figure)
        const scriptFont = new Font(figure)
        scriptFont.copyFrom(font)
        scriptFont.setSize(fontSize * Figure_defaults.SCRIPTSIZE)
        tc.set("font", scriptFont)
        tc.set("baseline", baseline + Figure_defaults.SUPERSCRIPT_OFFSET * fontSize)
        return tc
    }
}

class SubscriptText extends ContextTransformer {
    constructor(text) { super(null, text) }
    transformContext(tc, figure) {
        const baseline = tc.get("baseline"), font = tc.get("font"),
              fontSize = font.getSize()
        tc = new TextContext(tc, figure)
        const scriptFont = new Font(figure)
        scriptFont.copyFrom(font)
        scriptFont.setSize(fontSize * Figure_defaults.SCRIPTSIZE)
        tc.set("font", scriptFont)
        tc.set("baseline", baseline + Figure_defaults.SUBSCRIPT_OFFSET * fontSize)
        return tc
    }
}

class ItalicText extends ContextTransformer {
    constructor(text) { super(null, text) }
    transformContext(tc, figure) {
        const font = tc.get("font")
        tc = new TextContext(tc, figure)
        const italicFont = new Font(figure)
        italicFont.copyFrom(font)
        italicFont.setStyle("italic")
        tc.set("font", italicFont)
        return tc
    }
}

class BoldText extends ContextTransformer {
    constructor(text) { super(null, text) }
    transformContext(tc, figure) {
        const font = tc.get("font")
        tc = new TextContext(tc, figure)
        const newFont = new Font(figure)
        newFont.copyFrom(font)
        newFont.setStyle("bold")
        tc.set("font", newFont)
        return tc
    }
}

// A GraphicalObject intended to be overridden by users with arbitrary
// rendering code.  It draws itself by calling a method draw(context, frame,
// time, x0, y0, x1, y1), simplifying the coding.
class UserDefined extends GraphicalObject {
    constructor(figure) {
        super(figure)
    }
    render() {
        const [x0, y0, x1, y1] = evaluate([this.x0(), this.y0(), this.x1(), this.y1()], this.figure.currentValuation),
              fig = this.figure
        this.draw(fig.ctx, fig.currentFrame.index, fig.animationTime, x0, x1, y0, y1)
    }
    // Override this to change the appearance of this object
    //   context: the 2D rendering context
    //   frame: the index of the current animation frame
    //   time: the fraction of the current frame that is completed (0-1)
    draw(context, frame, time, x0, x1, y0, y1) {
        context.fillStyle = 'gray'
        context.fillRect(x0, y0, x1-x0, y1-y0)
    }
}

class InteractiveObject extends LayoutObject {
    constructor(figure) {
        super()
        figure.GraphicalObjects.push(this)
        figure.interactives.push(this)
        this.figure = figure
    }
    render() {}
}
InteractiveObject.prototype.renderIfVisible = GraphicalObject.prototype.renderIfVisible
InteractiveObject.prototype.visible = GraphicalObject.prototype.visible

// A handle that can be dragged interactively.
class Handle extends InteractiveObject {
    constructor(figure, strokeStyle, x, y) {
        super(figure)
        const vx = new Variable(figure, "hx"),
              vy = new Variable(figure, "hy")
        this.x_ = vx
        this.y_ = vy
        this.variables = () => [vx, vy]
        this.size = 5
        this.strokeStyle = strokeStyle || figure.strokeStyle
        this.isActive = true
        this.isVisible = true
        figure.positive(vx, 0)
        figure.positive(vy, 0)
        figure.leq(vx, figure.canvasRect().x1())
        figure.leq(vy, figure.canvasRect().y1())
    }
    x() { return this.x_ }
    y() { return this.y_ }
    w() { return 0 }
    h() { return 0 }
    renderIfVisible() {
        if (this.visible(this.figure.currentFrame)) this.render()
    }
    render() {
        const figure = this.figure, ctx = figure.ctx, valuation = figure.currentValuation
        if (ctx.printMedia) return
        ctx.beginPath()
        const x = evaluate(this.x(), valuation),
              y = evaluate(this.y(), valuation)
        ctx.moveTo(x - this.size, y)
        ctx.lineTo(x, y + this.size)
        ctx.lineTo(x + this.size, y)
        ctx.lineTo(x, y - this.size)
        ctx.closePath()
        ctx.lineWidth = 1
        if (this.strokeStyle != null) {
            ctx.strokeStyle = this.strokeStyle
            ctx.setLineDash([])
            ctx.stroke()
        }
    }
    setStrokeStyle(style) {
        this.strokeStyle = style
        return this
    }
    mousedown(x, y, e) {
        if (this.figure.currentValuation === undefined)
            { console.error("No current valuation"); return }
        const hx = evaluate(this.x(), this.figure.currentValuation),
              hy = evaluate(this.y(), this.figure.currentValuation),
              expand = e.type == "touchstart" ? 20 : 0,
              // XXX should use radiusX/radiusX property when available
              r = this.size + expand
        if (sqdist(x - hx, y - hy) <= r * r) {
            this.figure.focused = this
            return false
        } else {
            return true
        }
    }
    mouseup(e) {
        if (this.figure.focused == this) {
            // console.log("Handle lost focus")
            this.figure.focused = null
            if (this.xcon) {
                this.figure.removeConstraints(this.xcon, this.ycon)
            }
        }
    }
    mousemove(x, y, e) {
        if (this.xcon) {
            this.figure.removeConstraints(this.xcon, this.ycon)
        }
        this.xcon = new NearZero(this.figure, new Minus(this.x(), x), 10)
        this.ycon = new NearZero(this.figure, new Minus(this.y(), y), 10)
        if (!this.figure.renderNeeded) {
            this.figure.renderNeeded = true
            setTimeout(() => this.figure.renderIfDirty(true), 0) // collapse multiple renders
        }
    }
    active() { return true }
    visible() { return true }
    toString() { return "Handle" }
}

class Button extends InteractiveObject {
    constructor(figure) {
        super(figure)
        const vx = new Variable(figure, "x"),
              vy = new Variable(figure, "y")
        this.x_ = vx
        this.y_ = vy
        this.variables = () => [vx, vy]
        figure.geq(vx,0)
        figure.geq(vy,0)
        figure.leq(vx, figure.canvasRect().x1())
        figure.leq(vy, figure.canvasRect().y1())

        this.size = 30
        this.fillStyle = "#ccc"
        this.strokeStyle = "#444"
        this.pressed = false
    }
    x() { return this.x_ }
    y() { return this.y_ }
    w() { return this.size }
    h() { return this.size }
    
    inbounds(mx, my, x, y) {
        if (mx < x - this.size * 0.5) return false
        if (mx > x + this.size * 0.5) return false
        if (my > y + this.size * 0.3) return false
        if (my < y - this.size * 0.3) return false
        return true
    }
    mousedown(mx, my, e) {
        if (this.figure.currentValuation === undefined)
            { console.error("No current valuation"); return }
        const valuation = this.figure.currentValuation,
              x = evaluate(this.x(), valuation),
              y = evaluate(this.y(), valuation)
        if (!this.inbounds(mx, my, x, y)) return true
        this.pressed = true
        this.figure.focused = this
        this.render(this.figure)
        return false
    }
    mouseup(e) {
        if (this.figure.currentValuation === undefined)
            { console.error("No current valuation"); return true }
        const valuation = this.figure.currentValuation,
              x = evaluate(this.x(), valuation),
              y = evaluate(this.y(), valuation)
        if (!this.pressed) return true
        this.pressed = false
        this.figure.focused = null
        this.render(this.figure)
        this.activate()
        return false
    }
    mousemove(mx, my, e) {
        const valuation = this.figure.currentValuation,
              x = evaluate(this.x(), valuation),
              y = evaluate(this.y(), valuation)
        if (this.inbounds(mx, my, x, y)) return
        if (this.pressed) {
            this.pressed = false
            this.figure.focused = null
            this.render(this.figure)
        }
    }
    active() { return true }
}

// A button that advances the animation.
class AdvanceButton extends Button {
    constructor(figure) {
        super(figure)
    }
    w() { return this.size * 1.1}
    h() { return this.size * 0.7 }

    render() {
        const figure = this.figure, ctx = figure.ctx, valuation = figure.currentValuation
        if (ctx.printMedia) return
        const s = this.size
        ctx.beginPath()
        const x = evaluate(this.x(), valuation),
              y = evaluate(this.y(), valuation)
        ctx.save()
        ctx.translate(x - s * 0.5, y - s*0.3)
        Paths.roundedRect(ctx, 0, s, 0, s*0.6, s*0.3)
        if (this.pressed)
            ctx.fillStyle = "#888"
        else
            ctx.fillStyle = this.fillStyle
        ctx.fill()
        ctx.strokeStyle = this.strokeStyle
        ctx.lineWidth = s/10
        ctx.setLineDash([])
        ctx.stroke()
        ctx.fillStyle = ctx.strokeStyle
        ctx.beginPath()
        ctx.moveTo(s*0.3, s*0.1)
        ctx.lineTo(s*0.8, s*0.3)
        ctx.lineTo(s*0.3, s*0.5)
        ctx.closePath()
        ctx.fill()
        ctx.restore()
    }
    activate() {
        this.figure.advance()
    }
}
AdvanceButton.prototype.installHolder = GraphicalObject.prototype.installHolder

// A global is an expression whose value may change but is not affected by 
// the values of variables that are being solved for. Its value is provided
// by a function that is passed to the constructor.
class Global extends Expression {
    constructor(fun, name) {
        super()
        this.fun = fun
        this.name = name
    }
    evaluate(valuation, doGrad) {
        const v0 = this.checkCache(valuation, doGrad)
        if (v0) return v0
        const v = (this.fun)(valuation)
        return this.recordCache(valuation, doGrad, doGrad ? [v, getZeros(valuation.length)] : v)
    }
    backprop(task) {}
    addDependencies(task) {
        // despite lack of backpropagation, this is needed to force initialization
    }
    toString() { return this.name || "Global" }
}

// An expression that reports its value and gives information
// about backpropagation.
class DebugExpr extends Expression {
    constructor(name, expr) {
        super()
        this.expr = expr
        this.name = name
    }
    evaluate(valuation, doGrad) {
        const r = evaluate(this.expr, valuation, doGrad)
        console.log("debug expr " + this.name + " evaluated to ", r)
        return r
    }
    backprop(task) {
        console.log("backpropagating expr " + this.name + " : " + this.bpDiff)
        task.propagate(this.expr, this.bpDiff)
    }
    addDependencies(task) {
        task.prepareBackProp(this.expr)
    }
    variables() {
        return exprVariables(this.expr)
    }
    toString() {
        return "debug(" + this.expr + ")"
    }
}

class DOMElementBox extends LayoutObject {
    constructor(figure, id) {
        super()
        if (typeof id == "string") {
            this.obj = document.getElementById(id)
            if (!this.obj) {
                console.error("Can't find DOM element with id  " + id)
            }
            this.id = id
        } else {
            this.obj = id
            this.id = "anonymous"
        }
        if (!isFigure(figure)) {
            console.error("DOMElementBox requires a figure to compute coordinates relative to")
        }
        this.figure = figure
        this.x_ = this.centerX()
        this.y_ = this.centerY()
    }
    boundingRect() {
        return this.obj.getBoundingClientRect()
    }
    x() { return this.x_ }
    y() { return this.y_ }
    x0() { return new Global(() => this.boundingRect().left - this.figure.canvas.getBoundingClientRect().left, "DOM element " + this.id + ".x0") }
    y0() { return new Global(() => this.boundingRect().top - this.figure.canvas.getBoundingClientRect().top, "DOM element " + this.id + ".y0") }
    w() { return new Global(() => this.boundingRect().width, "DOM element " + this.id + ".w") }
    h() { return new Global(() => this.boundingRect().height, "DOM element " + this.id + ".h") }
    x1() { return new Global(() => {
             const b = this.boundingRect()
             return b.right - this.figure.canvas.getBoundingClientRect().left
           }, "DOM element " + this.id + ".x1")
         }
    y1() { return new Global(() => {
             const b = this.boundingRect()
             return b.bottom - this.figure.canvas.getBoundingClientRect().top
           }, "DOM element " + this.id + ".y1")
         }
    addDependencies(task) {
        task.prepareBackProp(this.x())
        task.prepareBackProp(this.y())
    }
}

function fullWindowCanvas(canvas) {
    const resizeCanvasToWindow = () => {
        const _width = window.innerWidth,
              _height = window.innerHeight
        // console.log("Resizing to " + _width + " " + _height)
        canvas.style.width = _width + "px"
        canvas.style.height = _height + "px"
    }
    addEventListener('resize', 
        () => resizeCanvasToWindow(canvas)
    )
    resizeCanvasToWindow(canvas)
}

class CanvasRect extends LayoutObject {
    constructor(figure) {
        super()
        this.figure = figure
    }
    x0() { return 0 }
    x1() { return new Global(() => {
        if (!this.figure.width) this.figure.setupCanvas()
        return this.figure.width
    })}
    y0() { return 0 }
    y1() { return new Global(() => this.figure.height) }
    w() { return new Global(() => this.figure.width) }
    h() { return new Global(() => this.figure.height) }
    x() { return this.centerX() }
    y() { return this.centerY() }
    backprop(task) {}
    addDependencies(task) {}
}

function exceedsError(x, y) {
    if (isNaN(x) || isNaN(y)) return true
    if (x > y) {
        const t = x; x = y; y = t
    }
    return (Math.abs(1.0 - y/x) > 0.00001 && Math.abs(y-x) > 0.00001)
}

function rgbStyle(r,g,b) {
    return `rgb(${r}, ${g}, ${b})`
}

function drawCorners(figure) {
    const ctx = figure.ctx,
          canvas = figure.canvas
    ctx.strokeStyle = "black"
    ctx.beginPath()
    ctx.moveTo(0, 0)
    ctx.lineTo(Figure_defaults.TRIANGLE_SIZE, 0)
    ctx.lineTo(0, Figure_defaults.TRIANGLE_SIZE)
    ctx.lineWidth = 1.5
    ctx.fillStyle = "green"
    ctx.closePath()
    ctx.fill()
    ctx.setLineDash([])
    ctx.stroke()

    ctx.beginPath()
    ctx.moveTo(figure.width, figure.height)
    ctx.lineTo(figure.width - Figure_defaults.TRIANGLE_SIZE, figure.height)
    ctx.lineTo(figure.width, figure.height - Figure_defaults.TRIANGLE_SIZE)
    ctx.closePath()
    ctx.fill()
    ctx.stroke()
}

class Corners extends GraphicalObject {
    constructor(figure)  {
        super(figure) 
    }
    render() { drawCorners(this.figure) }
}

function autoResize() {
    window.addEventListener('resize',
      () =>
        Figures.forEach(f => {
            f.renderNeeded = true
            setTimeout(() => f.renderIfDirty(false), 1000/Figure_defaults.FRAMERATE) // collapse multiple renders
        })
        )
}

  return ({
    figure, Figure, Figures, Frame, Variable, LayoutObject, GraphicalObject,
    Point, Box, Line, Connector, Rectangle, Square, Circle, Ellipse, Polygon,
    ContainedText, TextContext, TextItem, createText, InteractiveObject,
    CanvasRect, Button, LineLabel, Group, ConstraintGroup, Loss, Font, Corners,
    Expression, Minus, Plus, Times, Divide, Sqrt, Distance, Average, Min, Max,
    Projection, Conditional, Paths, autoResize, rgbStyle, Global, UserDefined,
    evaluate, SolverCallback, fullWindowCanvas, setupTouchListeners,
    Figure_defaults, isFigure, statistics, currentValue, drawLineEndSeg,
    evaluate, sqdist, exprVariables, DebugExpr
  })
}()
