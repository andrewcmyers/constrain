"use strict";

// A package for creating animated figures in JavaScript canvases, similar to
// the sort of animated figure you would put into a slide presentation, or for
// web-based course notes.
// 
// There is a set of Figure objects recorded in the array Figures. Each one
// is attached to a separate canvas.

var Constrain = function() {

const Figures = []

// There is a set of Variables that can be adjusted to minimize an objective
// function generated by summing costs from various constraints. Depending on
// which frame a figure is on, different variables are active and solved for.
//
// Expressions can be built out of Variables. Constraints are built using expressions.
// They have a cost that is supposed to be as small as possible (zero, if the constraint
// is fully satisfiable). The solver tries to minimize the total cost of all constraints.
//
// Variables, expressions, and constraints are not associated with particular
// figures (except for some special expressions), so they can actually be
// reused across figures.
//
// Associated with each figure is a set of GraphicalObjects that know how to
// render themselves based on associated Variables.
//
// When new graphical objects are created, their style is set to their figure's
// style by default, but can be changed later.

const Figure_defaults = {
    ARROW_SIZE : 12,
    FONT_SIZE : 12,
    LINEWIDTH : 1,
    TRIANGLE_SIZE : 10,
    FRAMERATE : 60,
    FONT_NAME : "sans-serif"
}

// A Figure is attached to a canvas and knows how to render itself. It has a
// set of associated Frames which can be stepped through. GraphicalObjects and
// Constraints can be attached to a figure.
// 
class Figure {
    // Create a figure appearing in a canvas.  'canvas' should be either the
    // canvas HTML element or, for convenience, its id attribute as a string
    constructor(canvas) {
        this.figure = this
        if (typeof canvas == "object" && canvas.constructor == HTMLCanvasElement) {
            this.canvas = canvas
        } else if (typeof canvas == "string") {
            this.canvas = canvas = document.getElementById(canvas)
            this.name = canvas
        } else {
            console.error("new Figure() expects a canvas or a canvas id")
            return
        }
        this.ctx = canvas.getContext("2d")
        this.setupListeners()
        this.initObjects()
        this.scale = window.devicePixelRatio ? window.devicePixelRatio : 1; // canvas units per HTML "pixel"
        this.time = 0
        this.currentFrame = undefined // current frame object
        this.frameRate = Figure_defaults.FRAMERATE
        this.Frames = []
        this.wrapFrames = false // does advancing from last frame go back to first
        this.frameIndex = []
    // default styles
        this.setFillStyle("white")
        this.setStrokeStyle("black")
        this.setLineWidth(Figure_defaults.LINEWIDTH)
        this.setFontSize(Figure_defaults.FONT_SIZE)
        this.setFontName(Figure_defaults.FONT_NAME)
        this.repeat = false
        this.fadeColor = 'white'
        Figures.push(this)
        if (canvas.style.padding && canvas.style.padding != "0px")
            console.error("Canvas input will not work correctly with padding")
    }
    setupCanvas() {
        const canvas = this.canvas, br = canvas.getBoundingClientRect(),
              _width = br.width, _height = br.height
        this.width = _width
        this.height = _height
//       console.log("Width, height are " + _width + "," + _height)
        this.canvas.width = _width * this.scale;
        this.canvas.height = _height * this.scale;
        this.ctx.setTransform(this.scale, 0, 0, this.scale, 0, 0)
    }
    setupListeners() {
        const canvas = this.canvas
        this.canvas.addEventListener('mousedown', (e) => {
            const x = e.offsetX, y = e.offsetY
            // alternatively: could use clientX/clientY with getBoundingClientRect
            this.interactives.forEach(i => {
                if (!i.mousedown(x, y, e)) return false
            })
            return true
        })
        this.canvas.addEventListener('mouseup', (e) => {
            const x = e.offsetX, y = e.offsetY
            this.interactives.forEach(i => {
                if (!i.mouseup(x, y, e)) return false
            })
            return true
        })
        this.canvas.addEventListener('mousemove', (e) => {
            if (!this.focused) return
            const x = e.offsetX, y = e.offsetY
            this.focused.mousemove(x, y, e)
        })
    }
    initObjects() {
        this.GraphicalObjects = []
        this.Constraints = []
        this.Variables = []
        this.numVariables = 0
        this.interactives = []
        this.events = []
        this.focused = null
        this.renderNeeded = false
    }
    initialValuation() {
        if (this.Variables.length != this.numVariables) {
            alert("oops " + this.numVariables + " " + this.Variables.length)
            console.error("oops")
        }
        const result = new Array(this.activeVariables.length)
        for (let i = 0; i < this.activeVariables.length; i++) {
            const v = this.activeVariables[i]
            if (v.hint != null) result[i] = v.hint
            else result[i] = 100 // why not?
        }
        return result
    }
    evaluate(e) {
        return evaluate(e, this.currentValuation)
    }
    numberVariables() {
        let i = 0, a = [], frame = this.currentFrame
        this.Variables.forEach(v => v.removeIndex())
        function activate(v) {
            if (v.index !== undefined) return
            if (v.constructor != Variable)
                console.error("not a variable")
            v.setIndex(i)
            a[i] = v
            i++
        }
        this.GraphicalObjects.forEach(g => {
            if (g.active()) {
                g.variables().forEach(activate)
            }
        })
        this.Constraints.forEach(c => {
            if (c.active())
                c.variables().forEach(activate)
        })
        this.activeVariables = a
    }
    resetValuation() {
        this.numberVariables()
        this.currentValuation = this.initialValuation()
    }
    // Add one or more constraints that should be satisfied
    // If an array is passed as an argument, each element is added
    // as a constraint.
    // A constraint should return a nonnegative cost
    // Normally, constraints call this method themselves
    addConstraints(...constraints) {
        constraints.flat().forEach(c => {
            if (!this.Constraints.includes(c)) this.Constraints.push(c)
        })
    }
    removeConstraints(...constraints) {
        constraints = constraints.flat()
        this.Constraints = this.Constraints.filter(c => !constraints.includes(c))
    }

    totalCost(valuation) {
        let cost = 0
        this.forAllConstraints(c =>
            cost += c.getCost(valuation, false)
        )
        return cost
    }

    costGrad(valuation, doGrad) {
        let n = valuation.length, cost = 0, dcost = new Array(n).fill(0)
        function handleConstraint(con) {
            if (con.parent !== undefined) return
            if (!con.active()) return
            const result = con.getCost(valuation, doGrad)
            let c, dc
            if (doGrad) {
                [c, dc] = result
                if (isNaN(c))
                    console.error("failed to evaluate cost")
                dcost = numeric.add(dcost, dc)
            } else {
                c = result
            }
            cost += c
        }
        this.Constraints.forEach(handleConstraint)
        if (!doGrad) {
            return cost
        } else {
            return [cost, dcost]
        }
    }
    updateValuation() {
        this.numberVariables()
        if (this.currentValuation === undefined || this.currentValuation.length < this.activeVariables.length)
            this.resetValuation()
        if (this.currentValuation.length > this.activeVariables.length)
            this.currentValuation = this.currentValuation.slice(0, this.activeVariables.length)
        const result = this.solveConstraints(this.currentValuation)
        // console.log("Solved for " + this.currentValuation.length + " variables with " +
        //  + this.Constraints.length + " constraints in " + result.iterations + " iterations:")
        // console.log(result)
        return result.solution
    }
    solveConstraints(valuation) {
        let tol = 0.001, doGrad = true, fig = this
        if (valuation === undefined) {
            console.error("Need initial valuation")
            return
        }
        if (doGrad) {
            return uncmin((v,d) => fig.costGrad(v,d), valuation, tol, 1000)
        } else {
            return numeric.uncmin(this.totalCost, valuation, tol, undefined, 1000)
        }
    }

// Rendering
    renderIfDirty() {
        if (this.currentFrame === undefined) {
            console.log("current frame not defined yet, skipping render")
            return
        }
        if (this.renderNeeded) {
            this.render(this.animationTime)
            this.renderNeeded = false
        }
    }
    // Render this figure for current time t in [0,1] (fraction of completion of current frame)
    render() {
        if (undefined === this.animationTime) {
            console.log("Animation time not set")
            this.animationTime = 0
        }
        this.setupCanvas()
        // console.log("Rendering figure at time " + t)
        this.ctx.setTransform(this.scale, 0, 0, this.scale, 0, 0)
        this.ctx.clearRect(0, 0, this.width, this.height)
        this.currentValuation = this.updateValuation()
        this.renderFromValuation()
    }
    renderFromValuation() {
        this.GraphicalObjects.forEach(g => {
            if (g.parent === undefined && g.renderIfVisible)
              g.renderIfVisible()
        })
    }

// Frame management

    // create one or more new frames, returning either the
    // single new frame or an array of the new frames.
    addFrame(...names) {
        if (names.length > 1) {
            return names.flat().map(n => new Frame(this, n))
        } else {
            return new Frame(this, names)
        }
    }

    getFrame(i) {
        return this.Frames[i]
    }

    // Start this figure. If no frames have been defined, create a
    // single non-animated frame.
    start() {
        // console.log("starting figure")
        if (this.Frames.length == 0)
            this.Frames[0] = new Frame(this)
        this.currentFrame = this.Frames[0]
        if (!this.currentFrame) { console.error("No current frame!?") }
        if (document.readyState == "complete") {
            console.log("document is ready, starting first frame")
            this.startCurrentFrame()
        } else {
            // console.log("document is not ready, starting listener")
            window.addEventListener('load', () => {
                // console.log("Document loaded, starting frame")
                this.startCurrentFrame()
            })
        }
    }

    // Reset this figure back to the first frame
    reset() {
        this.currentFrame = this.Frames[0]
        this.render()
    }

// return the next frame or null if we are at the end already
    nextFrame() {
        if (this.currentFrame === undefined) {
            return this.Frames[0]
        }
        for (let i = 0; i < this.Frames.length; i++) {
            if (this.Frames[i] == this.currentFrame &&
                i + 1 < this.Frames.length) {
                return this.Frames[i+1]
            }
        }
        return null
    }

    prevFrame() {
        if (this.currentFrame === undefined) return null
        for (let i = 0; i < this.Frames.length; i++) {
            if (this.Frames[i] == this.currentFrame && i > 0)
                return this.Frames[i-1]
        }
        return null
    }

    advance() {
        const f = this.nextFrame()
        if (f) {
            this.currentFrame = f
            this.startCurrentFrame()
        } else {
            if (this.repeat) {
                this.animate(2000, 10000/this.frameRate,
                  () => {
                    const col = this.fadeColor ? 'white' : this.fadeColor
                    this.ctx.fillStyle = col
                    this.ctx.globalAlpha = 0.05
                    this.ctx.fillRect(0, 0, this.width, this.height)
                  },
                  () => {
                    this.reset()
                    this.render()
                  })
            }
        }
    }

    rewind() {
        const f = this.prevFrame()
        if (f) {
            this.currentFrame = f
            this.startCurrentFrame()
        } else {
            console.log("At first frame already")
        }
    }

    setRepeat(f) {
        this.repeat = f
    }
    setFadeColor(c) {
        this.fadeColor = c
    }

    // Whether this figure is at the end of the last frame
    isComplete() {
        return (this.nextFrame() == null) && (this.animationTime >= 1 || this.currentFrame.length == 0)
    }

    // Whether this figure is at the first frame
    isReset() {
        return (!this.currentFrame || this.Frames[0] == this.currentFrame)
    }

    complete() {
        this.currentFrame = this.Frames[this.Frames.length - 1]
        this.endCurrentFrame()
    }

    animate(frameLength, frameInterval, action, completedAction) {
        const t0 = new Date().getTime()
        this.interval = setInterval(() => {
            const t = new Date().getTime() - t0,
                  frac = t/this.currentFrame.length
            this.animationTime = frac
            if (frac >= 1) {
                this.animationTime = 1
                this.stopTimer()
                completedAction()
            } else {
                this.animationTime = frac
                action()
            }
        })
        console.log("Started interval timer " + this.interval)
    }

    // Start rendering (and animating, if necessary) the current frame
    startCurrentFrame() {
        this.animationTime = 0
        this.stopTimer()
        if (!this.currentFrame) {
            console.error("no current frame")
        }
        if (this.currentFrame.length > 0) {
            console.log("starting animated frame " + this.name + " in " + this.figure.name)
            this.animate(this.currentFrame.length, 1000/this.frameRate,
                () => this.render(),
                () => this.endCurrentFrame()
            )
        } else {
            console.log("starting static frame " + this.currentFrame.name + " in " + this.figure.name)
            delete this.interval
            this.render()
        }
    }

    endCurrentFrame() {
        if (this.currentFrame === undefined) return
        console.log("Ending frame " + this.name)
        this.animationTime = 1
        this.stopTimer()
        this.render()
        if (this.nextFrame() && this.nextFrame().autoAdvance) {
            this.advance()
        }
    }

    stopTimer() {
        if (this.interval !== undefined) {
            console.log("Stopping interval timer " + this.interval)
            clearInterval(this.interval)
            delete this.interval
        }
    }

// ---- default style control: some objects will use figure defaults if style parameters are not provided ----

    // Set the default fill style
    setFillStyle(style) {
        this.fillStyle = style
    }

    // Set the default stroke style
    setStrokeStyle(style) {
        this.strokeStyle = style
    }

    // Set the default line width
    setLineWidth(w) {
        this.lineWidth = w
    }

    // Set default font size
    setFontSize(s) {
        this.fontSize = s
        return this
    }

    // Set default font name
    setFontName(f) {
        this.fontName = f
        return this
    }

// ---- utility functions for creating constraints ----

    equal(...e) {
        if (e.length == 2) return new NearZero(this, new Minus(e[0], e[1]))
        const a = []
        for (let i = 1; i < e.length; i++) {
            a.push(new NearZero(this, new Minus(e[0], e[i])))
        }
        return new ConstraintGroup(this, a)
    }
    geq(e1, e2) {
        return new NearZero(this, new Relu(new Minus(e2, e1)))
    }
    positive(e) {
        return this.geq(e, 0)
    }
    leq(e1, e2) {
        return new NearZero(this, new Relu(new Minus(e1, e2)))
    }

    // constraints to pin all the objects at the same location
    pin(...objects) {
        objects = objects.flat()
        let w, h
        if (objects[0].w !== undefined) {
            w = objects[0].w()
            h = objects[0].h()
        }
        const r = []
        for (let i = 1; i < objects.length; i++) {
            r.push(this.equal(objects[0].x(), objects[i].x()))
            r.push(this.equal(objects[0].y(), objects[i].y()))
            if (w === undefined && objects[i].w !== undefined) {
                w = objects[i].w()
                h = objects[i].h()
            } else
            if (w !== undefined && objects[i].w !== undefined) {
                r.push(this.equal(w, objects[i].w()))
                r.push(this.equal(h, objects[i].h()))
            }
        }
        if (r.length == 1) return r[0]
        else return new ConstraintGroup(this, r)
    }

    distance(p1, p2) {
        return new Distance(p1, p2)
    }

    // Return a list of contraints that align a variable number of objects both
    // horizontal and vertically.
    // Allowed options for horizontal are:
    //    "none" : no alignment
    //    "left/right/center" : align left edges/center/right edges
    //    "abut" : make objects abut each other directly
    //    "distribute": objects have equal space separating them
    // Allowed options for vertical are the same except "top" and "bottom"
    //    replace "left" and "right".
    // Objects can either be passed as an array or as a variable number of arguments
    // starting from the third argument.
    align(horizontal, vertical, objlist) {
        const result = []
        if (objlist.constructor != Array) 
            objlist = argsToArray(arguments, 2)
        switch (horizontal) {
            case "none": break
            case "center": 
                for (let i = 1; i < objlist.length; i++)
                    result.push(this.equal(objlist[i].x(), objlist[0].x()))
                break
            case "left":
                for (let i = 1; i < objlist.length; i++)
                    result.push(this.equal(objlist[i].x0(), objlist[0].x0()))
                break
            case "right":
                for (let i = 1; i < objlist.length; i++)
                    result.push(this.equal(objlist[i].x1(), objlist[0].x1()))
                break
            case "abut":
                for (let i = 1; i < objlist.length; i++)
                    result.push(this.equal(objlist[i-1].x1(), objlist[i].x0()))
                break
            case "distribute":
                const d = new Minus(objlist[1].x0(), objlist[0].x1())
                for (let i = 2; i < objlist.length; i++)
                    result.push(this.equal(new Minus(objlist[i].x0(), objlist[i-1].x1()), d))
                break
        }
        switch (vertical) {
            case "none": break;
            case "center": 
                for (let i = 1; i < objlist.length; i++)
                    result.push(this.equal(objlist[i].y(), objlist[0].y()))
                break
            case "top":
                for (let i = 1; i < objlist.length; i++)
                    result.push(this.equal(objlist[i].y0(), objlist[0].y0()))
                break
            case "bottom":
                for (let i = 1; i < objlist.length; i++)
                    result.push(this.equal(objlist[i].y1(), objlist[0].y1()))
                break
            case "abut":
                for (let i = 1; i < objlist.length; i++)
                    result.push(this.equal(objlist[i-1].y1(), objlist[i].y0()))
                break
            case "distribute":
                const d = new Minus(objlist[1].y0(), objlist[0].y1())
                for (let i = 2; i < objlist.length; i++)
                    result.push(this.equal(new Minus(objlist[i].y0(), objlist[i-1].y1()), d))
                break
        }
        return result
    }

    after(frame, ...objs) {
        if (objs.length == 1) return new After(this, frame, objs[0])
        return objs.flat().map(o => new After(this, frame, o))
    }
    before(frame, ...objs) {
        if (objs.length == 1) return new Before(this, frame, objs[0])
        objs.flat().map(o => new Before(this, frame, o))
    }
    between(frame1, frame2, ...objs) {
        if (objs.length == 1) return new Before(this, frame2, new After(this, frame1, objs[0]))
        objs.flat().map(o => new Before(this, frame2, new After(this, frame1, o)))
    }
    drawAfter(frame, ...objs) {
        if (objs.length == 1) return new DrawAfter(this, frame, objs[0])
        return objs.flat().map(o => new DrawAfter(this, frame, o))
    }
    drawBefore(frame, ...objs) {
        if (objs.length == 1) return new DrawBefore(this, frame, objs[0])
        objs.flat().map(o => new DrawBefore(this, frame, o))
    }
    drawBetween(frame1, frame2, ...objs) {
        if (objs.length == 1) return new DrawBefore(this, frame2, new DrawAfter(this, frame1, objs[0]))
        objs.flat().map(o => new DrawBefore(this, frame2, new DrawAfter(this, frame1, o)))
    }

// ---- Utility methods for creating figure objects ----

    canvasSize() {
        return new CanvasSize(this.figure)
    }
    rectangle(fillStyle, strokeStyle, lineWidth, x_hint, y_hint, w_hint, h_hint) {
        return new Rectangle(this, fillStyle, strokeStyle, lineWidth, x_hint, y_hint, w_hint, h_hint)
    }
    square(fillStyle, strokeStyle, lineWidth, x_hint, y_hint, w_hint) {
        return new Square(this, fillStyle, strokeStyle, lineWidth, x_hint, y_hint, w_hint)
    }
    circle(fillStyle, strokeStyle, lineWidth, x_hint, y_hint, w_hint) {
        return new Circle(this, fillStyle, strokeStyle, lineWidth, x_hint, y_hint, r_hint)
    }
    ellipse(fillStyle, strokeStyle, lineWidth, x_hint, y_hint, r_hint) {
        return new Ellipse(this, fillStyle, strokeStyle, lineWidth, x_hint, y_hint, r_hint)
    }
    line(strokeStyle, lineWidth, x0, y0, x1, y1) {
        return new Line(this, strokeStyle, lineWidth, x0, y0, x1, y1)
    }
    horzLine(strokeStyle, lineWidth, x0, x1, y) {
        return new HorzLine(this, strokeStyle, lineWidth, x0, x1, y)
    }
    vertLine(strokeStyle, lineWidth, x, y0, y1) {
        return new VertLine(this, strokeStyle, lineWidth, x, y0, y1)
    }
    hspace() { return new HSpace(this) }
    vspace() { return new VSpace(this) }
    label(string, fontSize, fontName, fillStyle, x, y) {
        return new Label(this, string, fontSize, fontName, fillStyle, x, y)
    }
    handle(style) {
        return new Handle(this, style)
    }
    connector(...objects) {
        return new Connector(this, ...objects)
    }
    DOMElement(id) {
        return new DOMElementBox(this, id)
    }
    group(...objects) {
        return new Group(this, ...objects)
    }
    linear(frame, e1, e2) {
        return new Linear(this, frame, e1, e2)
    }
    smooth(frame, e1, e2) {
        return new Smooth(this, frame, e1, e2)
    }
    // Create a point with variables for its coordinates
    point() {
        if (arguments.length == 2) {
            return new Point(arguments[0], arguments[1])
        } else {
            if (arguments.length != 0) {
                console.error("point(...) expects 0 or 2 arguments")
            }
            const x = new Variable(this, "px"), y = new Variable(this, "py")
            return new Point(x, y)
        }
    }
    advanceButton() {
        return new AdvanceButton(this)
    }
// ---- Utility methods for creating expressions ----
    plus(x, y) { return new Plus(x, y) }
    minus(x, y) { return new Minus(x, y) }
    times(x, y) { return new Times(x, y) }
    divide(x, y) { return new Divide(x, y) }
    max(x, y) { return new Max(x, y) }
    min(x, y) { return new Min(x, y) }
    average(x, y) { return new Average(x, y) }
    distance(p1, p2) { return new Distance(p1, p2) }
    nearZero(e, cost) { return new NearZero(this, e, cost) }
    constraintGroup(...c) { return new ConstraintGroup(this, ...c) }
    group(...g) { return new Group(this, ...g) }
}

function isFigure(figure) {
    return (figure.connector !== undefined)
}

// From numeric-1.2.6.js. Modified to allow f to supply the gradient directly.
// Minimizes a function f(x) whose gradient is g(x)
// fg(x) or fg(x, false) must return just f(x)
// fg(x, true) must return [ f(x), (grad f)(x)] or [f(x0), undefined]. In the former case,
//   (grad f) must return an array whose length is the same as x. In the latter
//   case, a numeric gradient is computed using f, more expensively.
function uncmin(fg,x0,tol,maxit,callback,options) {
    var grad = numeric.gradient;
    if(typeof options === "undefined") { options = {}; }
    if(typeof tol === "undefined") { tol = 1e-8; }
    function gradient(x) { return grad(fg, x); };
    if(typeof maxit === "undefined") maxit = 1000;
    x0 = numeric.clone(x0);
    var n = x0.length;
    var [f0, g0] = fg(x0, true);
    var f1,g1,df0;
    if (isNaN(f0))
        throw new Error('uncmin: f(x0) is a NaN!');
    if (g0 === undefined) g0 = gradient(x0);
    // let g0_ = gradient(x0);
    var max = Math.max, norm2 = numeric.norm2;
    tol = max(tol,numeric.epsilon);
    var step,H1 = options.Hinv || numeric.identity(n);
    var dot = numeric.dot, inv = numeric.inv, sub = numeric.sub, add = numeric.add, ten = numeric.tensor, div = numeric.div, mul = numeric.mul;
    var all = numeric.all, isfinite = numeric.isFinite, neg = numeric.neg;
    var it=0,i,s,x1,y,Hy,Hs,ys,i0,t,nstep,t1,t2;
    var msg = "";
    while(it<maxit) {
        if(typeof callback === "function") { if(callback(it,x0,f0,g0,H1)) { msg = "Callback returned true"; break; } }
        if(!all(isfinite(g0))) { msg = "Gradient has Infinity or NaN"; break; }
        step = neg(dot(H1,g0));
        if(!all(isfinite(step))) { msg = "Search direction has Infinity or NaN"; break; }
        nstep = norm2(step);
        if(nstep < tol) { msg="Newton step smaller than tol"; break; }
        t = 1;
        df0 = dot(g0,step);
        // line search
        x1 = x0;
        while(it < maxit) {
            if(t*nstep < tol) { break; }
            s = mul(step,t);
            x1 = add(x0,s);
            f1 = fg(x1);
            if(f1-f0 >= 0.1*t*df0 || isNaN(f1)) {
                t *= 0.5;
                ++it;
                continue;
            }
            break;
        }
        if(t*nstep < tol) { msg = "Line search step size smaller than tol"; break; }
        if(it === maxit) { msg = "maxit reached during line search"; break; }
        [f1, g1] = fg(x1, true);
        if (g1 === undefined) g1 = gradient(x1);
        y = sub(g1,g0);
        ys = dot(y,s);
        Hy = dot(H1,y);
        H1 = sub(add(H1,
                mul(
                        (ys+dot(y,Hy))/(ys*ys),
                        ten(s,s)    )),
                div(add(ten(Hy,s),ten(s,Hy)),ys));
        x0 = x1;
        f0 = f1;
        g0 = g1;
        ++it;
    }
    return {solution: x0, f: f0, gradient: g0, invHessian: H1, iterations:it, message: msg};
}

// A frame of the animation. Frames can auto-advance
// to the next frame or require manual advancing.
// frame.index gives the index of the frame in the
// current figure.
class Frame {
    constructor(figure, name) {
        if (name === undefined) name = figure.Frames.length
        if (!isFigure(figure)) {
            console.error("First argument to new Frame() must be a figure")
        }
        this.index = figure.Frames.length
        this.name = name
        figure.Frames.push(this)
        this.autoAdvance = false
        this.length = 0
    }
    // Set the length of this frame (ms)
    setLength(ms) {
        this.length = ms
        return this
    }
    setAutoAdvance(a) {
        this.autoAdvance = a
        return this
    }
    isAfter(f) {
        return this.index >= f.index
    }
    isBefore(f) {
        return this.index < f.index
    }
    toString() {
        return "Frame " + this.name
    }
}

function eventInElement(event, element) {
    var rect = element.getBoundingClientRect();
    var x = event.clientX;
    if (x < rect.left || x >= rect.right) return false;
    var y = event.clientY;
    if (y < rect.top || y >= rect.bottom) return false;
    return true;
}

// An Expression is used to build constraints or and to express useful
// quantities in terms of the solved-for values of variables.
class Expression {
    constructor() {}
    evaluate(valuation) {
        console.log("Don't know how to evaluate this expression")
        return 0
    }
    variables() { return [] }
}

// A Variable is solved for by the constraint solver. It does not
// keep track of its own value. A variable has an index that determines
// its location in the valuation array.
//
class Variable extends Expression {
    constructor(figure, basename, hint) {
        super()
        this.basename = basename + "_" + figure.numVariables
        this.index = figure.numVariables // overridden later by numberVariables()
        this.figure = figure
        figure.Variables.push(this)
        figure.numVariables++
        if (hint !== undefined) {
            this.hint = hint
        }
    }
    evaluate(valuation, doGrad) {
        if (this.index === undefined) {
            console.error("Can't evaluate a variable that has not been solved for")
            return 0
        }
        if (doGrad) {
            let g = this.grad, n = valuation.length
            if (!g || g.length != n) {
                g = new Array(n).fill(0)
                g[this.index] = 1
                this.grad = g // save gradient for later
            }
            if (this.figure.activeVariables[this.index] !== this) {
                console.error("Variable index does not agree with active variables list")
            }
            return [valuation[this.index], g]
        } else {
            return valuation[this.index]
        }
    }
    setHint(v) {
        this.hint = v
    }
    setIndex(n) {
        this.index = n
    }
    removeIndex() {
        delete this.index
    }
    variables() { return [this] }
}

// This variable caches an array of zeros of the appropriate length
var zeros

function getZeros(n) {
    if (zeros && zeros.length == n) return zeros
    zeros = new Array(n).fill(0)
    return zeros
}

// var cacheHits = 0, cacheMisses = 0, variableCacheHits = 0, falseCacheHits = 0

// The variables used by expression e.
function exprVariables(e) {
    if (typeof e == "number") return []
    if (e === undefined)
        console.error("undefined expr")
    if (!e.variables)
        console.error("no variables method")
    return e.variables()
}

// The value of expression expr in the given valuation (an array of variable values).
// If doGrad is true, it returns an array [v, g] where is the value of the expression and
// g is its gradient with respect to all the variables.
function evaluate(expr, valuation, doGrad) {
    // alert("evaluating " + expr)
    if (expr === undefined) {
        console.error("undefined expr")
    }
    if (valuation === undefined) {
        console.error("undefined valuation")
    }
    let n = valuation.length
    switch (typeof expr) {
        case "number": return !doGrad ? expr : [ expr, getZeros(n) ]
        case "function":
            console.error("Tried to evaluate a function ${expr}. Did you forget to invoke a property using ()?")
            return 0;
        default:
        /*
            if (expr.cachedValuation === valuation && expr.cachedDoGrad != doGrad)
                falseCacheHits++
            if (expr.cachedValuation === valuation &&
                expr.cachedDoGrad === doGrad) {
                cacheHits++
                if (expr.constructor === Variable) variableCacheHits++
            } else
                cacheMisses++
        */

            if (expr.evaluate) {
                const r = expr.evaluate(valuation, doGrad)
                // expr.cachedValuation = valuation
                // expr.cachedDoGrad = doGrad
                return r
            } else {
                if (expr.constructor == Array) {
                    return expr.map(e => evaluate(e, valuation, doGrad))
                } else {
                    console.error("don't know how to evaluate this: " + expr)
                }
            }
    }
}

class BinaryExpression extends Expression {
    constructor(e1, e2) {
        super()
        if (e1 === undefined)
            console.error("undefined e1")
        if (e2 === undefined)
            console.error("undefined e2")
        this.e1 = e1
        this.e2 = e2
        return this
    }
    evaluate(valuation, doGrad) {
        if (!doGrad || !this.gradop)
            return this.operation(evaluate(this.e1, valuation), evaluate(this.e2, valuation))
        const [a, da] = evaluate(this.e1, valuation, true)
        const [b, db] = evaluate(this.e2, valuation, true)
        return this.gradop(a, b, da, db)
    }
    variables() {
        return exprVariables(this.e1).concat(exprVariables(this.e2))
    }
}

class Minus extends BinaryExpression {
    constructor(e1, e2) { super(e1, e2) }
    operation(a, b) { return a - b }
    gradop(a, b, da, db) {
        return [a - b, numeric.sub(da, db)]
    }
}

class Plus extends BinaryExpression {
    constructor(e1, e2) { super(e1, e2) }
    operation(a, b) { return a + b }
    gradop(a, b, da, db) { return [a + b, numeric.add(da, db)] }
}

class Average extends BinaryExpression {
    constructor(e1, e2) { super(e1, e2) }
    operation(a, b) { return (a + b)/2 }
    gradop(a, b, da, db) {
        return [ (a + b)/2, numeric.mul(numeric.add(da, db), 0.5) ]
    }
}

class Times extends BinaryExpression {
    constructor(e1, e2) { super(e1, e2) }
    operation(a, b) { return a * b }
    gradop(a, b, da, db) {
        return [ a * b, numeric.add(numeric.mul(a, db), numeric.mul(b, da)) ]
    }
}
class Divide extends BinaryExpression {
    constructor(e1, e2) { super(e1, e2) }
    operation(a, b) { return a / b }
    gradop(a, b, da, db) {
        return [a / b, numeric.add(numeric.mul(-a/(b*b), db),  numeric.mul(da, 1/b))]
    }
}

class NaryExpression extends Expression {
    constructor(...arglist) {
        super()
        this.args = arglist.flat()
    }
    evaluate(valuation, doGrad) {
        const vals = this.args.map((e) => evaluate(e, valuation, doGrad))
        if (doGrad) return this.gradop(vals)
        else return this.operation(vals)
    }
    variables() {
        let result = []
        this.args.forEach(e => { result = result.concat(exprVariables(e)) })
        return result
    }
}

class Min extends NaryExpression {
    constructor(...args) { super(...args) }
    operation(vals) {
        let best = vals[0], n = vals.length
        for (let i = 1; i < n; i++) {
            best = Math.min(vals[i], best)
        }
        return best
    }
    gradop(vals) {
        let [best, db] = vals[0], n = vals.length
        for (let i = 1; i < n; i++) {
            let [a, da] = vals[i]
            if (a < best) {
                best = a
                db = da
            }
        }
        return [best, db]
    }
}

class Max extends NaryExpression {
    constructor(...args) { super(...args) }
    operation(vals) {
        let best = vals[0], n = vals.length
        for (let i = 1; i < n; i++) {
            best = Math.max(vals[i], best)
        }
        return best
    }
    gradop(vals) {
        let [best, db] = vals[0], n = vals.length
        for (let i = 1; i < n; i++) {
            let [a, da] = vals[i]
            if (a > best) {
                best = a
                db = da
            }
        }
        return [best, db]
    }
}

class Distance {
    constructor(p1, p2) {
        this.p1 = p1
        this.p2 = p2
    }
    evaluate(valuation, doGrad) {
      if (!doGrad) {
        const [x1, y1] = this.p1.evaluate(valuation),
              [x2, y2] = this.p2.evaluate(valuation),
              xd = x2 - x1,
              yd = y2 - y1,
              rad = sqdist(xd, yd)
        return Math.sqrt(rad)
      }
      const [p1, dp1] = this.p1.evaluate(valuation, true),
            [p2, dp2] = this.p2.evaluate(valuation, true),
            [x1, y1] = p1,
            [x2, y2] = p2,
            xd = x2 - x1,
            yd = y2 - y1,
            [dx1, dy1] = dp1,
            [dx2, dy2] = dp2,
            dxd = numeric.sub(dx2, dx1),
            dyd = numeric.sub(dy2, dy1),
            rad = sqdist(xd, yd),
            v = Math.sqrt(rad),
            drad = numeric.add(numeric.mul(2, xd, dxd), numeric.mul(2, yd, dyd))
      if (v == 0) return [0, getZeros(dx1.length)]
      return [v, numeric.mul(0.5/v, drad)]
    }
    variables() {
        return exprVariables(this.p1).concat(exprVariables(this.p2))
    }
}

class UnaryExpression extends Expression {
    constructor(e) {
        super()
        this.expr = e
    }
    evaluate(valuation, doGrad) {
        if (!doGrad) return this.operation(evaluate(this.expr, valuation))
        const [a, da] = evaluate(this.expr, valuation, true)
        return this.gradop(a, da)
    }
    variables() {
        return exprVariables(this.expr)
    }
}

class Abs extends UnaryExpression {
    constructor(e) { super(e) }
    operation(a) { return Math.abs(a) }
    gradop(a, da) {
        if (a > 0) return [a, da]
        return [-a, -da]
    }
}

class Neg extends UnaryExpression {
    constructor(e) { super(e) }
    operation(a) { return -a }
    gradop(a, da) { return [-a, -da] }
}

// square root operation
class Sqrt extends UnaryExpression {
    constructor(e) { super(e) }
    operation(a) { return Math.sqrt(a) }
    gradop(a, da) {
        if (a <= 0) return [0, getZeros(da.length)]
        const s = Math.sqrt(a)
        return [s, numeric.mul(0.5/s), da]
    }
}

// squaring operation
class Sqr extends UnaryExpression {
    constructor(e) { super(e) }
    operation (a) { return a*a }
    gradop(a, da) {
        return [a*a, numeric.mul(2*a, da)]
    }
}

// max(0,x)
class Relu extends UnaryExpression {
    constructor(e) { super(e) }
    operation(a) { if (a < 0) return 0; else return a }
    gradop(a, da) { 
        if (a < 0) return [0, getZeros(da.length)]
        return [a, da]
    }
}

// A fixed value between 0 and 1 representing the
// time during the current animation frame
class Time extends Expression {
    constructor(figure) {
        super()
        this.figure = figure
    }
    evaluate(valuation, doGrad) {
        const t = this.figure.animationTime
        return doGrad ? [t, getZeros(valuation.length)] : t ;
    }
    variables() { return [] }
}

// A Linear can interpolate, as a function of time, between two numbers or
// between any two expressions that evaluate to 1-D arrays, such as Points.
class Linear extends Expression {
    constructor(figure, frame, e1, e2) {
        super()
        this.figure = figure
        this.frame = frame
        this.e1 = e1
        this.e2 = e2
    }
    interp(t) { return t }
    evaluate(valuation, doGrad) {
        const figure = this.figure
        if (figure.currentFrame.isBefore(this.frame)) {
            return evaluate(this.e1, valuation, doGrad)
        }
        if (figure.currentFrame.isAfter(this.frame) && figure.currentFrame != this.frame) {
            return evaluate(this.e2, valuation, doGrad)
        }
        const v1 = evaluate(this.e1, valuation, doGrad),
              v2 = evaluate(this.e2, valuation, doGrad),
              b = this.interp(this.figure.animationTime),
              a = 1 - b
        switch (doGrad ? typeof(v1[0]) : typeof(v1)) {
            case "number":
                if (!doGrad) return v1 * a  + v2 * b
                return [ v1[0] * a + v2[0] * b,
                         numeric.add(numeric.mul(v1[1], a), numeric.mul(v2[1], b)) ]
            case "object":
                if (v1.constructor == Array) {
                    var result = new Array(v1.length)
                    for (i = 0; i < v1.length; i++) {
                        result[i] = numeric.add(numeric.mul(v1[i], a), numeric.mul(v2[i], b))
                    }
                    return result
                }
        }
        console.error("Don't know how to interpolate between " + v1 + " and " + v2)
    }
}

class Smooth extends Linear {
    constructor(figure, frame, e1, e2) {
        super(figure, frame, e1, e2)
    }
    interp(t) { return cubicInterpWeight(t) }
}

function cubicInterpWeight(t) {
    return t*t*(3 - 2*t);
}

// A Temporal is an object that only exists in some frames. It can be
// a GraphicalObject or a Constraint. By default an object exists and
// is visible in every frame.
//
class Temporal {
    constructor(figure) {
        this.figure = figure
    }
    active() { return true }

    // Is this object visible in frame f?
    visible() { return true }

    renderIfVisible() {
        if (this.visible(this.figure.currentFrame)) this.render()
    }
}

// A TemporalFilter contains a graphical object or a constraint.
class TemporalFilter extends Temporal {
    constructor(figure, obj) {
        super(figure)
        if (obj.constructor == Array) {
            console.error("Sorry, a Temporal can only hold one graphical object or one constraint. Use a Group or ConstraintGroup instead.")
        }
        if (!isFigure(figure)) {
            console.error("A Temporal must be constructed with a Figure")
        }
        this.obj = obj
        obj.installHolder(figure, this, obj) // tell the figure to install this object in the appropriate way
    }
    x() { return this.obj.x() }
    y() { return this.obj.y() }
    x0() { return this.obj.x0() }
    x1() { return this.obj.x1() }
    y0() { return this.obj.y0() }
    y1() { return this.obj.y1() }
    w() { return this.obj.w() }
    h() { return this.obj.h() }
    ul() { return this.obj.ul() }
    ll() { return this.obj.ll() }
    lr() { return this.obj.lr() }
    ur() { return this.obj.ur() }
    p1() { return this.obj.p1() }
    p2() { return this.obj.p2() }
    lc() { return this.obj.lc() }
    cr() { return this.obj.cr() }
    uc() { return this.obj.uc() }
    cl() { return this.obj.cl() }
    center() { return this.obj.center() }
    render() {
        this.obj.renderIfVisible()
    }
    getCost(valuation, doGrad) {
        if (this.active(this.figure.currentFrame)) {
            return this.obj.getCost(valuation, doGrad)
        } else {
            return zeroCost(valuation, doGrad)
        }
    }
    variables() {
        if (this.active(this.figure.currentFrame)) return this.obj.variables() 
        else return []
    }
    installHolder(figure, holder, child) {
        this.obj.installHolder(figure, holder, child)
    }
    bestConnectionPt(px, py, valuation) {
        return this.obj.bestConnectionPt(px, py, valuation)
    }
}

function zeroCost(valuation, doGrad) {
    return doGrad ? [0, getZeros(valuation.length)] : 0
}

class After extends TemporalFilter {
    constructor(figure, frame, obj) {
        super(figure, obj)
        this.frame = frame
    }
    active() {
        return this.figure.currentFrame.isAfter(this.frame)
    }
}

class DrawAfter extends TemporalFilter {
    constructor(figure, frame, obj) {
        super(figure, obj)
        this.frame = frame
    }
    visible() {
        return this.figure.currentFrame.isAfter(this.frame)
    }
}

class Before extends TemporalFilter {
    constructor(figure, frame, obj) {
        super(figure, obj)
        this.frame = frame
    }
    active() {
        return !this.figure.currentFrame.isAfter(this.frame)
    }
}

class DrawBefore extends TemporalFilter {
    constructor(figure, frame, obj) {
        super(figure, obj)
        this.frame = frame
    }
    visible() {
        return !this.figure.currentFrame.isAfter(this.frame)
    }
}


// A Constraint has a cost that the system tries to minimize
class Constraint extends Temporal {
    constructor(figure) {
        super(figure)
        if (!isFigure(figure)) {
            console.error("Constraints require an associated Figure")
            throw "no"
        }
        this.figure = figure
        figure.addConstraints(this)
    }
    getCost(valuation, doGrad) {
        console.error("No cost function defined for this constraint " + this.constructor)
        return zeroCost(valuation, doGrad)
    }
    variables() { return [] }
    installHolder(figure, holder, child) {
        if (child.parent !== undefined) {
            console.error("Child Constraint already has a parent")
            return
        }
        child.parent = holder
        figure.addConstraints(holder)
        for (let i = 0; i < figure.Constraints.length; i++) {
            if (figure.Constraints[i] === child) {
                figure.Constraints[i] = holder
                child.parent = holder
                break
            }
        }
        if (child.parent !== holder) {
            console.error("Child constraint not at top level")
            figure.Constraints.push(holder)
        }
    }
}

class NearZero extends Constraint {
    constructor(figure, expr, cost) {
        super(figure)
        this.expr = expr
        this.cost = cost
    }
    getCost(valuation, doGrad) {
      if (!doGrad) {
        const v = evaluate(this.expr, valuation)
        if (this.cost != null) return v*v*this.cost
        else return v*v
      } else {
        const [v, dv] = evaluate(this.expr, valuation, true)
        if (this.cost != null) return [ v*v*this.cost, numeric.mul(v, dv, this.cost, 2) ]
        else return [ v*v, numeric.mul(2*v, dv) ]
      }
    }
    variables() {
        return exprVariables(this.expr)
    }
}

function constraintsCost(a, valuation, doGrad) {
    if (a.constructor !== Array) console.error("constraintsCost expects an array of constraints")
    if (a.length == 0) return zeroCost(valuation, doGrad)
    if (a.length == 1) return a[0].getCost(valuation, doGrad)
    if (!doGrad) {
        let cost = 0
        a.forEach(c => { cost += c.getCost(valuation, doGrad) })
        return cost
    } else {
        let cost = 0, dc = getZeros(valuation.length)
        a.forEach(c => {
            const [cc, cd] = c.getCost(valuation, true)
            cost += cc
            dc = numeric.add(dc, cd)
        })
        return [cost, dc]
    }
}

class ConstraintGroup extends Constraint {
    constructor(figure, ...constraints) {
        super(figure)
        this.constraints = constraints.flat()
    }
    getCost(valuation, doGrad) {
        return constraintsCost(this.constraints, valuation, doGrad)
    }
    variables() {
        let r = []
        this.constraints.forEach(c => {
            r = r.concat(c.variables())
        })
        return r
    }
}

// A LayoutObject does not support rendering and does not necessarily
// know what figure it is part of. Its size is 0 by default.
class LayoutObject {
    constructor() { }
    x0() { return new Minus(this.x(), new Times(this.w(), 0.5)) }
    x1() { return new Plus(this.x(), new Times(this.w(), 0.5)) }
    y0() { return new Minus(this.y(), new Times(this.h(), 0.5)) }
    y1() { return new Plus(this.y(), new Times(this.h(), 0.5)) }
    ul() { return new Point(this.x0(), this.y0()) }
    ur() { return new Point(this.x1(), this.y0()) }
    ll() { return new Point(this.x0(), this.y1()) }
    lr() { return new Point(this.x1(), this.y1()) }
    lc() { return new Point(this.x(), this.y1()) }
    cr() { return new Point(this.x1(), this.y()) }
    uc() { return new Point(this.x(), this.y0()) }
    cl() { return new Point(this.x0(), this.y()) }
    centerX() { return new Average(this.x0(), this.x1()) }
    centerY() { return new Average(this.y0(), this.y1()) }
    center() { return new Point(this.x(), this.y()) }
    width() { return this.w() }
    height() { return this.h() }
    w() { return 0 }
    h() { return 0 }
    variables() { return [] }
    connectionPts() {
        return [
                new Point(this.x(), this.y()),
                new Point(this.x1(), this.y()),
                new Point(this.x0(), this.y()),
                new Point(this.x(), this.y0()),
                new Point(this.x(), this.y1())
               ]
    }
    bestConnectionPt(px, py, valuation) {
        let [x,y] = evaluate([this.x(), this.y()], valuation)
        const scs = evaluate(this.connectionPts(), valuation),
              scdirs = scs.map(p => {
                                  const [sx,sy] = p,
                                        nm = norm2d(sx - x, sy - y)
                                  return nm == 0 ? [0,0] : [(sx - x)/nm, (sy - y)/nm]
                                })
        let pn = norm2d(px - x, py - y),
            pxn = (px-x)/pn, pyn = (py-y)/pn
        let best = scs[0], bd = scdirs[0][0] * pxn + scdirs[0][1] * pyn // cos of angle
        for (let i = 1; i < scs.length; i++) {
           const d = scdirs[i][0] * pxn + scdirs[i][1] * pyn
           if (d > bd) { bd = d; best = scs[i] }
        }
        return best
    }
    render() {
        console.log("Attempted to render an object that has no rendering defined.")
    }
    variables() {
        return []
    }
}

// A GraphicalObject is centered at (x,y) and has a width w and height h.
// It also has some style attributes. The lineWidth attribute can be a constrained attribute too.
class GraphicalObject extends LayoutObject {
    constructor(figure, fillStyle, strokeStyle, lineWidth, x_hint, y_hint, w_hint, h_hint) {
        super()
        this.figure = figure
        figure.GraphicalObjects.push(this)
        const prefix = this.id ? this.id + "_" : ""
        this.x_= new Variable(figure, prefix + "x", x_hint)
        this.y_ = new Variable(figure, prefix + "y", y_hint)
        this.w_ = new Variable(figure, prefix + "w", w_hint)
        this.h_ = new Variable(figure, prefix + "h", h_hint)

        if (fillStyle !== undefined) this.fillStyle = fillStyle
            else this.fillStyle = figure.fillStyle
        if (strokeStyle !== undefined) this.strokeStyle = strokeStyle
            else this.strokeStyle = figure.strokeStyle
        if (lineWidth !== undefined) this.lineWidth = lineWidth
            else this.lineWidth = figure.lineWidth
        this.lineDash = undefined
    }
    x() { return this.x_ }
    y() { return this.y_ }
    w() { return this.w_ }
    h() { return this.h_ }
    variables() {
        return [this.x(), this.y(), this.w(), this.h()]
    }
// builder methods for setting rendering style
    setFillStyle(s) {
        this.fillStyle = s
        return this
    }
    setStrokeStyle(s) {
        this.strokeStyle = s
        return this
    }
    setLineWidth(s) {
        this.lineWidth = s
        return this
    }
    setLineDash(d) {
        this.lineDash = d
        return this
    }
// convenience methods for positioning (by adding constraints)
    setX(x) { this.figure.equal(this.x(), x); return this }
    setY(y) { this.figure.equal(this.y(), y); return this }
    setXY(x, y) {
        this.figure.equal(this.x(), x)
        this.figure.equal(this.y(), y)
        return this
    }
    setW(w) { this.figure.equal(this.w(), w); return this }
    setH(h) { this.figure.equal(this.h(), h); return this }
// rendering control
    active() { return true }
    visible() { return true }
    renderIfVisible() {
        if (this.visible(this.figure.currentFrame))
            this.render()
    }
    installHolder(figure, holder, child) {
        if (child.parent !== undefined) {
            console.error("Child GraphicalObject already has a parent")
            return
        }
        for (let i = 0; i < figure.GraphicalObjects.length; i++) {
            if (figure.GraphicalObjects[i] === child) {
                figure.GraphicalObjects[i] = holder
                child.parent = holder
                break
            }
        }
        if (child.parent !== holder) {
            console.error("Child object not in top-level list")
            figure.GraphicalObjects.push(holder)
        }
    }
}

// A Point acts like a graphical object wrt layout but has no rendering, so it
// does not add itself to the graphical objects list. It also can act as an 
// expression.
class Point extends LayoutObject {
    constructor(vx, vy) {
        super()
        if (vx === undefined)
            console.log("undefined x")
        this.x_ = vx
        this.y_ = vy
    }
    x() { return this.x_ }
    y() { return this.y_ }
    evaluate(valuation, doGrad) {
      if (!doGrad) {
        const x = evaluate(this.x(), valuation),
              y = evaluate(this.y(), valuation)
        return [x, y]
      } else {
        const [x, dx] = evaluate(this.x(), valuation, true),
              [y, dy] = evaluate(this.y(), valuation, true)
        return [[x, y], [dx, dy]]

      }
    }
    variables() {
        return exprVariables(this.x()).concat(exprVariables(this.y()))
    }
}

class Group extends GraphicalObject {
    constructor(figure, ...objects) {
        super(figure)
        this.objects = objects.flat()
        this.objects.forEach(o => { o.parent = this })
    }
    variables() {
        const result = [], g = this
        this.objects.forEach(o => {
            o.variables().forEach(v => {
                result.push(v)
            })
        })
        return result
    }
    x() { return this.centerX() }
    y() { return this.centerY() }
    x0() { return new Min(this.objects.map(o => o.x0())) }
    x1() { return new Max(this.objects.map(o => o.x0())) }
    y0() { return new Min(this.objects.map(o => o.y0())) }
    y1() { return new Max(this.objects.map(o => o.y1())) }
    w() { return new Minus(this.x1(), this.x0()) }
    h() { return new Minus(this.y1(), this.y0()) }
    render() {
        this.objects.forEach(o => o.renderIfVisible())
    }
}

class Rectangle extends GraphicalObject {
    constructor(figure, fillStyle, strokeStyle, lineWidth, x_hint, y, w_hint, h_hint) {
        super(figure, fillStyle, strokeStyle, lineWidth, x_hint, y, w_hint, h_hint)
        figure.positive(this.h())
        figure.positive(this.w())
        this.cornerRadius = 0
    }
    render() {
        const figure = this.figure, ctx = figure.ctx, valuation = figure.currentValuation
        ctx.save()
        const [x0, x1, y0, y1] = evaluate([this.x0(), this.x1(), this.y0(), this.y1()], valuation)
        ctx.translate(x0, y0)
        ctx.beginPath()
        const w = x1-x0, h = y1-y0
        if (this.cornerRadius == 0) {
            ctx.moveTo(0, 0)
            ctx.lineTo(w, 0)
            ctx.lineTo(w, h)
            ctx.lineTo(0, h)
            ctx.closePath()
        } else {
            Paths.roundedRect(ctx, 0, w, 0, h, this.cornerRadius)
        }
        ctx.lineWidth = evaluate(this.lineWidth, valuation)
        if (this.fillStyle) {
            ctx.fillStyle = this.fillStyle
            ctx.fill()
        }
        if (this.strokeStyle) {
            ctx.strokeStyle = this.strokeStyle
            ctx.setLineDash(this.lineDash ? this.lineDash : [])
            ctx.stroke()
        }
        ctx.restore()
    }
    connectionPts() {
      if (this.cornerRadius == 0) {
        return [ this.ll(), this.lr(), this.ul(), this.ur(), this.cl(), this.cr(), this.uc(), this.lc() ]
      } else {
        const a = new Times(0.2929, this.cornerRadius)
        return [ this.cl(), this.cr(), this.uc(), this.lc(),
                    new Point(new Plus(this.x0(), a), new Plus(this.y0(), a)),
                    new Point(new Minus(this.x1(), a), new Plus(this.y0(), a)),
                    new Point(new Minus(this.x1(), a), new Minus(this.y1(), a)),
                    new Point(new Plus(this.x0(), a), new Minus(this.y1(), a)) ]
      }
    }
    setCornerRadius(r) {
        this.cornerRadius = r
        return this
    }
}

const Paths = {
    roundedRect: function (ctx, x0, x1, y0, y1, r) {
        const k = bezier_k
        ctx.beginPath()
        ctx.moveTo(x0+r, y0)
        ctx.lineTo(x1-r, y0)
        ctx.bezierCurveTo(x1-r+k*r, y0,  x1, y0+r-k*r,  x1, y0+r)
        ctx.lineTo(x1, y1-r)
        ctx.bezierCurveTo(x1, y1-r+k*r,  x1-r+k*r, y1,  x1-r, y1)
        ctx.lineTo(x0+r, y1)
        ctx.bezierCurveTo(x0+r-k*r, y1,  x0, y1-r+k*r, x0, y1-r)
        ctx.lineTo(x0, y0+r)
        ctx.bezierCurveTo(x0, y0+r-k*r,  x0+r-k*r, y0,  x0+r, y0)
        ctx.closePath()
    },
// Create an ellipse path with center (x,y) and x radius rx, y radius ry
    ellipse: function(ctx, x, y, rx, ry) {
        const k = bezier_k, rxk = rx * k, ryk = ry * k
        var x1 = x-rx, x2 = x-rxk, x3 = x+rxk, x4 = x+rx,
            y1 = y-ry, y2 = y-ryk, y3 = y+ryk, y4 = y+ry
        ctx.beginPath()
        ctx.moveTo(x4, y);
        ctx.bezierCurveTo(x4, y3,  x3, y4,  x, y4);
        ctx.bezierCurveTo(x2, y4,  x1, y3,  x1, y);
        ctx.bezierCurveTo(x1, y2,  x2, y1,  x, y1);
        ctx.bezierCurveTo(x3, y1,  x4, y2,  x4, y);
        ctx.closePath()
    },
    circle: function(ctx, x, y, r) {
        var rk = r*bezier_k, x1 = x-r, x2 = x-rk, x3 = x+rk, x4 = x+r,
                             y1 = y-r, y2 = y-rk, y3 = y+rk, y4 = y+r
    
        ctx.beginPath()
        ctx.moveTo(x4, y);
        ctx.bezierCurveTo(x4, y3,  x3, y4,  x, y4);
        ctx.bezierCurveTo(x2, y4,  x1, y3,  x1, y);
        ctx.bezierCurveTo(x1, y2,  x2, y1,  x, y1);
        ctx.bezierCurveTo(x3, y1,  x4, y2,  x4, y);
        ctx.closePath()
    }
}

class Square extends Rectangle {
    constructor(figure, fillStyle, strokeStyle, lineWidth, x_hint, y_hint, size_hint) {
        super(figure, fillStyle, strokeStyle, lineWidth, x_hint, y_hint, size_hint, size_hint)
        figure.equal(this.w(), this.h())
    }
}

class Ellipse extends GraphicalObject {
    constructor(figure, fillStyle, strokeStyle, lineWidth, x_hint, y_hint, size_hint) {
        super(figure, fillStyle, strokeStyle, lineWidth, x_hint, y_hint, size_hint, size_hint)
        figure.positive(this.h())
        figure.positive(this.w())
    }
    render() {
        const figure = this.figure, ctx = figure.ctx, valuation = figure.currentValuation
        ctx.save()
        const [x, y, w, h] = evaluate([this.x(), this.y(), this.w(), this.h()], valuation)
        ctx.translate(x - w/2, y - h/2)
        ctx.lineWidth = evaluate(this.lineWidth, valuation)
        Paths.ellipse(ctx, w/2, h/2, w/2, h/2)
        if (this.fillStyle) {
            ctx.fillStyle = this.fillStyle
            ctx.fill()
        }
        if (this.strokeStyle) {
            ctx.strokeStyle = this.strokeStyle
            ctx.setLineDash(this.lineDash ? this.lineDash : [])
            ctx.stroke()
        }
        ctx.restore()
    }
    connectionPts() {
        return [this.cl(), this.cr(), this.uc(), this.lc()]
    }
}

class Circle extends Ellipse {
    constructor(figure, fillStyle, strokeStyle, lineWidth, x_hint, y_hint, size_hint) {
        super(figure, fillStyle, strokeStyle, lineWidth, x_hint, y_hint, size_hint, size_hint)
        figure.ensure(figure.equal(this.h(), this.w()))
    }
}

// Draw an arrowhead of size s in the current style,
// based at x0,y0 and heading toward x1, y1
function drawArrowhead(ctx, x0, y0, x1, y1, s) {
    const dx = x1 - x0, dy = y1 - y0
    ctx.save()
    ctx.translate(x1, y1)
    ctx.rotate(Math.atan2(dy, dx))

    ctx.beginPath()
    ctx.moveTo(0,0)
    ctx.lineTo(-s, -0.4 * s)
    ctx.lineTo(-s, 0.4 * s)
    ctx.lineTo(0, 0)
    ctx.fill()

    ctx.restore()
}

const bezier_k = 0.552; // Bezier constant for circles

// Draw a circular "bullet" head of size s in the current style,
// based at x0,y0 and heading toward x1, y1
function drawBulletHead(ctx, x0, y0, x1, y1, s) {
    const dx = x1 - x0, dy = y1 - y0
    ctx.save()
    ctx.translate(x1, y1)
    ctx.rotate(Math.atan2(dy, dx))

    ctx.beginPath()
    ctx.moveTo(0,0)
    ctx.lineTo(-s, 0)
    ctx.stroke()
    Paths.circle(ctx, 0, 0, s/4)
    ctx.fill()
    ctx.restore()
}

const arrows = {
    arrow: drawArrowhead,
    bullet: drawBulletHead
}

// Draw an arrowhead for a line or curve endpoint at (x,y)
// where the previous point on the line or curve is at (x2, y2).
// Return the point where the line should extend from.
// If style is undefined, nothing is drawn and [x,y] is returned.
function drawLineEndSeg(ctx, style, size, x, y, x2, y2) {
    if (style === undefined) return [x,y]
    const xd = x - x2, yd = y - y2,
          d = norm2d(xd, yd),
          cosa = xd/d, sina = yd/d
    return drawLineEndDir(ctx, style, size, x, y, cosa, sina)
}

// Draw an arrowhead for a line or curve endpoint at (x,y)
// where the direction of the line is described by (cosa, sina).
// Return the point where the line should extend from.
// If style is undefined, nothing is drawn and [x,y] is returned.
function drawLineEndDir(ctx, style, size, x, y, cosa, sina) {
    if (style === undefined) return [x,y]
    let x1 = x - cosa * size,
        y1 = y - sina * size
    let arrowFun = arrows[style]
    if (arrowFun) arrowFun(ctx, x1, y1, x, y, size)
    return [x1, y1]
}

class Line extends GraphicalObject {
    constructor(figure, strokeStyle, lineWidth, x0, y0, x1, y1) {
        if (x0 == null) x0 = 100
        if (x1 == null) x1 = 100
        if (y0 == null) y0 = 200
        if (y1 == null) y1 = 200
        super(figure, undefined, strokeStyle, lineWidth, (x0 + x1)/2, (y0 + y1)/2, x1-x0, y1-y0)
        this.startArrowStyle = undefined
        this.endArrowStyle = undefined
        this.arrowSize = Figure_defaults.ARROW_SIZE
    }
    render() {
        const figure = this.figure, ctx = figure.ctx, valuation = figure.currentValuation
        ctx.beginPath()
        ctx.strokeStyle = this.strokeStyle
        ctx.lineWidth = evaluate(this.lineWidth, valuation)
        const [x0, x1, y0, y1] = evaluate([this.x0(), this.x1(), this.y0(), this.y1()], valuation)
        const xd = x1 - x0, yd = y1 - y0,
                d = norm2d(xd, yd),
                cosa = xd/d, sina = yd/d
        if (this.fillstyle) ctx.fillStyle = this.fillStyle
        else ctx.fillStyle = this.strokeStyle;
        ctx.setLineDash(this.lineDash ? this.lineDash : [])
        let [x2, y2] = drawLineEndDir(ctx, this.startArrowStyle, this.arrowSize, x0, y0, -cosa, -sina),
            [x3, y3] = drawLineEndDir(ctx, this.endArrowStyle, this.arrowSize, x1, y1, cosa, sina)

        ctx.beginPath()
        ctx.moveTo(x2, y2)
        ctx.lineTo(x3, y3)
        ctx.stroke()
    }
    setStartArrow(style) {
        this.startArrowStyle = style
        return this
    }
    setEndArrow(style) {
        this.endArrowStyle = style
        return this
    }
    setArrowSize(s) {
        this.arrowSize = s
        return this
    }
    p1() {
        return new Point(this.x0(), this.y0())
    }
    p2() {
        return new Point(this.x1(), this.y1())
    }
    setStart(p) {
        this.figure.pin(new Point(this.x0(), this.y0()), p)
        return this
    }
    setEnd(p) {
        this.figure.pin(new Point(this.x1(), this.y1()), p)
        return this
    }
}

class HorzLine extends Line {
    constructor(figure, strokeStyle, lineWidth, x0, x1, y) {
        super(figure, strokeStyle, lineWidth, x0, y, x1, y)
        figure.equal(this.h(), 0)
    }
}

class VertLine extends Line {
    constructor(figure, strokeStyle, lineWidth, x, y0, y1) {
        super(figure, strokeStyle, lineWidth, x, y0, x, y1)
        figure.equal(this.w(), 0)
    }
}

function sqdist(xd, yd) { return xd*xd + yd*yd }
function norm2d(xd, yd) { return Math.sqrt(xd*xd + yd*yd) }

// The slice of the arguments starting from i as
// an array. Omit i to convert all.
function argsToArray(args, i) {
    var result = []
    if (i === undefined) i = 0
    while (i < args.length) result.push(args[i++])
    return result
}
// If args is an arguments object, call f() on each argument
// starting from index i.
function argsForEach(args, i, f) {
    while (i < args.length) {
        f(args[i++])
    }
}

// A Connector draws a curve from a first object to a last object, passing near 
// intermediate objects along the way. Bezier splines are used to connect objects.
class Connector extends GraphicalObject {
    constructor(figure, ...objects) {
        super(figure, undefined, figure.strokeStyle, figure.lineWidth)
        this.fillStyle = this.strokeStyle
        this.objects = objects.flat()
        this.arrowSize = Figure_defaults.ARROW_SIZE
    }
    render() {
        const figure = this.figure, ctx = figure.ctx, valuation = figure.currentValuation
        let objs = this.objects,
            i = 0, m = objs.length-1
        const pts = objs.map(o => {return {x: evaluate(o.x(), valuation),
                                           y: evaluate(o.y(), valuation) }});

        [ pts[0].x, pts[0].y ] = objs[0].bestConnectionPt(pts[1].x, pts[1].y, valuation);
        [ pts[m].x, pts[m].y ] = objs[m].bestConnectionPt(pts[m-1].x, pts[m-1].y, valuation);
        ctx.strokeStyle = this.strokeStyle
        ctx.lineWidth = evaluate(this.lineWidth, valuation)
        ctx.setLineDash(this.lineDash ? this.lineDash : [])
        if (this.fillStyle) ctx.fillStyle = this.fillStyle
        if (this.startArrowStyle) {
            [pts[0].x, pts[0].y] = 
                drawLineEndSeg(ctx, this.startArrowStyle, this.arrowSize,
                               pts[0].x, pts[0].y, pts[1].x, pts[1].y)
        }
        if (this.endArrowStyle) {
            [pts[m].x, pts[m].y] = 
                drawLineEndSeg(ctx, this.endArrowStyle, this.arrowSize,
                               pts[m].x, pts[m].y, pts[m-1].x, pts[m-1].y)
        }

        ctx.beginPath()
        ctx.moveTo(pts[0].x, pts[0].y)
        let n = 0
        for (i = 0; i < m; i += n) {
            n = Math.min(3, m - i) // number of points in this segment, minus 1 (1-3)
            switch (n) {
                case 1: ctx.lineTo(pts[i+1].x, pts[i+1].y); break
                case 2: ctx.quadraticCurveTo(pts[i+1].x, pts[i+1].y, pts[i+2].x, pts[i+2].y); break
                case 3: ctx.bezierCurveTo(pts[i+1].x, pts[i+1].y, pts[i+2].x, pts[i+2].y,
                                          pts[i+3].x, pts[i+3].y); break
                default: console.error("internal error in Connector.render")
            }
        }
        ctx.strokeStyle = this.strokeStyle
        ctx.stroke()
    }
    setStartArrow(style) {
        this.startArrowStyle = style
        return this
    }
    setEndArrow(style) {
        this.endArrowStyle = style
        return this
    }
    setArrowSize(s) {
        this.arrowSize = s
        return this
    }
    variables() {
        let r = []
        this.objects.forEach(o =>
            r = r.concat(o.variables()))
        return r
    }
}

class HSpace extends GraphicalObject {
    constructor(figure) {
        super(figure)
        equal(this.h(), 0)
    }
    render() {}
    renderIfVisible() {}
}

class VSpace extends GraphicalObject {
    constructor(figure) {
        super(figure)
        equal(this.w(), 0)
    }
    render() {}
    renderIfVisible() {}
}

class Label extends GraphicalObject {
    constructor(figure, text, fontSize, fontName, fillStyle, x, y) {
        super(figure, fillStyle, undefined, 1, x, y)
        if (fillStyle != undefined) this.fillStyle = fillStyle
            else this.fillStyle = figure.strokeStyle
        if (fontSize != undefined) this.fontSize = fontSize
          else this.fontSize = figure.fontSize
        if (fontName !== undefined) this.fontName = fontName
          else this.fontName = figure.fontName
        this.text = text
        this.computeWidth(figure.ctx)
        this.setStrokeStyle(undefined)

        // Have to override GraphicalObject in the object itself
        this.w = function() { return this.width }
        this.h = function() { return this.fontSize }
        this.variables = function() { return [this.x(), this.y()] }
    }
    installFont() {
        this.figure.ctx.font = this.fontSize + "pt " + this.fontName
    }
    render() {
        const figure = this.figure, ctx = figure.ctx, valuation = figure.currentValuation
        this.installFont()
        const x = evaluate(this.x0(), valuation),
              y = evaluate(this.y1(), valuation)
        // console.log("rendering " + this.text + " at " + x + "," + y)
        if (this.fillStyle) {
            ctx.fillStyle = this.fillStyle
            ctx.fillText(this.text, x, y)
        }
        if (this.strokeStyle) {
            ctx.strokeStyle = this.strokeStyle
            if (this.lineWidth) {
                ctx.lineWidth = evaluate(this.lineWidth, valuation)
            }
            ctx.strokeText(this.text, x, y)
        }

    }
    computeWidth(ctx) {
        this.installFont()
        this.width = ctx.measureText(this.text).width
    }

    // Set font size
    setFontSize(s) {
        this.fontSize = s
        return this
    }

    // Set font name
    setFontName(f) {
        this.fontName = f
        return this
    }

}

// XXX add a special constraint for formatting cost
class FormattedText extends GraphicalObject {
    constructor(figure, ...text) {
        super(figure)
        this.words = []
        this.fontSize = figure.fontSize
        this.fontName = figure.fontName
        this.lineSpacing = 1.3
        text.forEach(t =>
            t.split(/  */).forEach(w => {
                if (w) this.words.push(w)
            })
        )
    }
    setLineSpacing(s) {
        this.lineSpacing = s
        return this
    }
    render() {
        const figure = this.figure, ctx = figure.ctx, valuation = figure.currentValuation
        const x0 = evaluate(this.x0(), valuation),
              x1 = evaluate(this.x1(), valuation),
              y1 = evaluate(this.y1(), valuation)
        let x = x0,
            y = evaluate(this.y0(), valuation) + this.fontSize
        ctx.font = this.fontSize + "pt " + this.fontName
        ctx.fillStyle = this.fillStyle
        const space = ctx.measureText(" ").width

        for (let i = 0; i < this.words.length; i++) {
            const wd = this.words[i],
                  width = ctx.measureText(wd).width
            if (x + width > x1) {
                x = x0
                y += this.fontSize * this.lineSpacing
            }
            ctx.fillText(wd, x, y)
            x += width
            x += space
        }
    }
}

// A GraphicalObject intended to be overridden by users with arbitrary
// rendering code.  It draws itself by calling a method draw(context, frame,
// time, x0, y0, x1, y1), simplifying the coding.
class UserDefined extends GraphicalObject {
    constructor(figure) {
        super(figure)
    }
    render() {
        const [x0, y0, x1, y1] = evaluate([this.x0(), this.y0(), this.x1(), this.y1()], this.figure.currentValuation),
              fig = this.figure
        this.draw(fig.ctx, fig.currentFrame.index, fig.animationTime, x0, x1, y0, y1)
    }
    // Override this to change the appearance of this object
    //   context: the 2D rendering context
    //   frame: the index of the current animation frame
    //   time: the fraction of the current frame that is completed (0-1)
    draw(context, frame, time, x0, x1, y0, y1) {
        context.fillStyle = 'gray'
        context.fillRect(x0, y0, x1-x0, y1-y0)
    }
}

class InteractiveObject extends LayoutObject {
    constructor(figure) {
        super()
        figure.GraphicalObjects.push(this)
        figure.interactives.push(this)
        this.figure = figure
    }
    render() {}
}
InteractiveObject.prototype.renderIfVisible = GraphicalObject.prototype.renderIfVisible
InteractiveObject.prototype.visible = GraphicalObject.prototype.visible

class Handle extends InteractiveObject {
    constructor(figure, strokeStyle, x, y) {
        super(figure)
        const vx = new Variable(figure, "hx"),
              vy = new Variable(figure, "hy")
        this.x = () => vx
        this.y = () => vy
        this.w = () => 0
        this.h = () => 0
        this.variables = () => [vx, vy]
        this.size = 5
        this.strokeStyle = strokeStyle
        this.isActive = true
        this.isVisible = true
        figure.positive(vx, 0)
        figure.leq(vx, figure.canvasSize().x1())
        figure.leq(vy, figure.canvasSize().y1())
    }
    renderIfVisible() {
        if (this.visible(this.figure.currentFrame)) this.render()
    }
    render() {
        const figure = this.figure, ctx = figure.ctx, valuation = figure.currentValuation
        ctx.beginPath()
        const x = evaluate(this.x(), valuation),
              y = evaluate(this.y(), valuation)
        ctx.moveTo(x - this.size, y)
        ctx.lineTo(x, y + this.size)
        ctx.lineTo(x + this.size, y)
        ctx.lineTo(x, y - this.size)
        ctx.closePath()
        ctx.lineWidth = 1
        ctx.strokeStyle = this.strokeStyle
        ctx.setLineDash([])
        ctx.stroke()
    }
    mousedown(x, y, e) {
        if (this.figure.currentValuation === undefined)
            { console.error("No current valuation"); return }
        const hx = evaluate(this.x(), this.figure.currentValuation),
              hy = evaluate(this.y(), this.figure.currentValuation)
        if (Math.abs(x - hx) + Math.abs(y - hy) <= this.size) {
            // console.log("Handle got focus")
            this.figure.focused = this
        }
    }
    mouseup(x, y, e) {
        if (this.figure.focused == this) {
            // console.log("Handle lost focus")
            this.figure.focused = null;
            if (this.xcon) {
                this.figure.removeConstraints(this.xcon, this.ycon)
            }
        }
    }
    mousemove(x, y, e) {
            if (this.xcon) {
                this.figure.removeConstraints(this.xcon, this.ycon)
            }
        this.xcon = new NearZero(this.figure, new Minus(this.x(), x), 0.1)
        this.ycon = new NearZero(this.figure, new Minus(this.y(), y), 0.1)
        this.figure.renderNeeded = true
        setTimeout(() => this.figure.renderIfDirty(), 0) // collapse multiple renders
    }
    active() { return true }
    visible() { return true }
}

class AdvanceButton extends InteractiveObject {
    constructor(figure, x, y) {
        super(figure)

        const vx = new Variable(figure, "x"),
              vy = new Variable(figure, "y")
        this.x_ = vx
        this.y_ = vy
        this.variables = () => [vx, vy]
        figure.geq(vx,0)
        figure.geq(vy,0)
        figure.leq(vx, figure.canvasSize().x1())
        figure.leq(vy, figure.canvasSize().y1())

        this.size = 30
        this.fillStyle = "#ccc"
        this.strokeStyle = "#444"
        this.pressed = false
    }
    x() { return this.x_ }
    y() { return this.y_ }
    w() { return this.size * 1.1}
    h() { return this.size * 0.7 }

    render() {
        const figure = this.figure, ctx = figure.ctx, valuation = figure.currentValuation
        const s = this.size
        ctx.beginPath()
        const x = evaluate(this.x(), valuation),
              y = evaluate(this.y(), valuation)
        ctx.save()
        ctx.translate(x - s * 0.5, y - s*0.3)
        Paths.roundedRect(ctx, 0, s, 0, s*0.6, s*0.3)
        if (this.pressed)
            ctx.fillStyle = "#888"
        else
            ctx.fillStyle = this.fillStyle
        ctx.fill()
        ctx.strokeStyle = this.strokeStyle
        ctx.lineWidth = s/10
        ctx.setLineDash([])
        ctx.stroke()
        ctx.fillStyle = ctx.strokeStyle
        ctx.beginPath()
        ctx.moveTo(s*0.3, s*0.1)
        ctx.lineTo(s*0.8, s*0.3)
        ctx.lineTo(s*0.3, s*0.5)
        ctx.closePath()
        ctx.fill()
        ctx.restore()
    }
    inbounds(mx, my, x, y) {
        if (mx < x - this.size * 0.5) return false
        if (mx > x + this.size * 0.5) return false
        if (my > y + this.size * 0.3) return false
        if (my < y - this.size * 0.3) return false
        return true
    }
    mousedown(mx, my, e) {
        if (this.figure.currentValuation === undefined)
            { console.error("No current valuation"); return }
        const valuation = this.figure.currentValuation,
              x = evaluate(this.x(), valuation),
              y = evaluate(this.y(), valuation)
        if (!this.inbounds(mx, my, x, y)) return true
        this.pressed = true
        this.figure.focused = this
        this.render(this.figure)
        return false
    }
    mouseup(mx, my, e) {
        if (this.figure.currentValuation === undefined)
            { console.error("No current valuation"); return true }
        const valuation = this.figure.currentValuation,
              x = evaluate(this.x(), valuation),
              y = evaluate(this.y(), valuation)
        if (!this.inbounds(mx, my, x, y)) return true
        if (!this.pressed) return true
        this.pressed = false
        this.figure.focused = null
        this.render(this.figure)
        this.figure.advance()
        return false
    }
    mousemove(mx, my, e) {
        const valuation = this.figure.currentValuation,
              x = evaluate(this.x(), valuation),
              y = evaluate(this.y(), valuation)
        if (this.inbounds(mx, my, x, y)) return
        if (this.pressed) {
            this.pressed = false
            this.figure.focused = null
            this.render(this.figure)
        }
    }
    active() { return true }
}
AdvanceButton.prototype.installHolder = GraphicalObject.prototype.installHolder

// A global is an expression whose value may change but is not affected by 
// the values of variables that are being solved for. Its value is provided
// by a function that is passed to the constructor.
class Global extends Expression {
    constructor(fun) {
        super()
        this.fun = fun
    }
    evaluate(valuation, doGrad) {
        const v = (this.fun)()
        return doGrad ? [v, getZeros(valuation.length)] : v
    }
}

class DOMElementBox extends LayoutObject {
    constructor(figure, id) {
        super()
        if (typeof id == "string")
            this.obj = document.getElementById(id)
        else
            this.obj = id
        if (!isFigure(figure)) {
            console.error("DOMElementBox requires a figure to compute coordinates relative to")
        }
        this.figure = figure
    }
    boundingRect() {
        return this.obj.getBoundingClientRect()
    }
    x() { return this.centerX() }
    y() { return this.centerY() }
    x0() { return new Global(() => this.boundingRect().left - this.figure.canvas.getBoundingClientRect().left) }
    y0() { return new Global(() => this.boundingRect().top - this.figure.canvas.getBoundingClientRect().top) }
    w() { return new Global(() => this.boundingRect().width) }
    h() { return new Global(() => this.boundingRect().height) }
    x1() { return new Global(() => {
             const b = this.boundingRect()
             return b.right - this.figure.canvas.getBoundingClientRect().left
           })
         }
    y1() { return new Global(() => {
             const b = this.boundingRect()
             return b.bottom - this.figure.canvas.getBoundingClientRect().top
           })
         }
}

function fullWindowCanvas(canvas) {
    const resizeCanvasToWindow = () => {
        const _width = window.outerWidth,
              _height = window.outerHeight
        console.log("Resizing to " + _width + " " + _height)
        canvas.style.width = _width + "px"
        canvas.style.height = _height + "px"
    }
    addEventListener('resize', 
        () => {
            resizeCanvasToWindow(canvas)
        }
    )
    resizeCanvasToWindow(canvas)
}

class CanvasSize extends LayoutObject {
    constructor(figure) {
        super()
        this.figure = figure
    }
    x0() { return 0 }
    x1() { return new Global(() => {
        if (!this.figure.width) this.figure.setupCanvas()
        return this.figure.width
    })}
    y0() { return 0 }
    y1() { return new Global(() => this.figure.height) }
    w() { return new Global(() => this.figure.width) }
    h() { return new Global(() => this.figure.height) }
    x() { return this.centerX() }
    y() { return this.centerY() }
}

function rgbStyle(r,g,b) {
    return `rgb(${r}, ${g}, ${b})`
}

function drawCorners(figure) {
    const ctx = figure.ctx,
          canvas = figure.canvas
    ctx.strokeStyle = "black"
    ctx.beginPath()
    ctx.moveTo(0, 0)
    ctx.lineTo(Figure_defaults.TRIANGLE_SIZE, 0)
    ctx.lineTo(0, Figure_defaults.TRIANGLE_SIZE)
    ctx.lineWidth = 1.5
    ctx.fillStyle = "green"
    ctx.closePath()
    ctx.fill()
    ctx.setLineDash([])
    ctx.stroke()

    ctx.beginPath()
    ctx.moveTo(figure.width, figure.height)
    ctx.lineTo(figure.width - Figure_defaults.TRIANGLE_SIZE, figure.height)
    ctx.lineTo(figure.width, figure.height - Figure_defaults.TRIANGLE_SIZE)
    ctx.closePath()
    ctx.fill()
    ctx.stroke()
}

class Corners extends GraphicalObject {
    constructor(figure)  {
        super(figure) 
    }
    render() { drawCorners(this.figure) }
}

function setupResize() {
    window.addEventListener('resize',
      () =>
        Figures.forEach(f => {
            f.renderNeeded = true
            setTimeout(() => f.renderIfDirty(), 1000/Figure_defaults.FRAMERATE) // collapse multiple renders
        })
        )
}

  return ({ Figure: Figure,
    Figures: Figures,
    Frame: Frame,
    Variable: Variable,
    GraphicalObject: GraphicalObject,
    Point: Point,
    Rectangle: Rectangle,
    Square: Square,
    Circle: Circle,
    Ellipse: Ellipse,
    FormattedText: FormattedText,
    Group: Group,
    ConstraintGroup: ConstraintGroup,
    Corners: Corners,
    Minus: Minus,
    Plus: Plus,
    Times: Times,
    Distance: Distance,
    Average: Average,
    Min: Min,
    Max: Max,
    Paths: Paths,
    setupResize: setupResize,
    rgbStyle: rgbStyle,
    Global: Global,
    UserDefined: UserDefined,
    evaluate: evaluate,
    fullWindowCanvas: fullWindowCanvas,
    isFigure: isFigure
  })
}()
