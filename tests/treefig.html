<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Language" content="en-us" />
  <meta http-equiv="Cache-Control" content="public, max-age=3600" /> <!-- cache for only 1 hour -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <script src="../numeric-1.2.6.js"></script>
  <script src="../constrain.js"></script>
  <script src="../constrain-trees.js"></script>
  <script>
    document.addEventListener('load', Constrain.autoResize)
  </script>

<canvas id="tree_anatomy" style="width: 220px; height: 200px"></canvas>

<script class=graphics>

// Once the nodes are generated, the changes should be expressed in terms of the
// nodes.
// 
// Problem is that the tree needs to end up in its final configuration at the end
// of the frame. Imperatively changing it is not declarative of course. Could
// imagine having the tree keep track of all its states per frame. Then a change
// is expressed simply by editing the tree to create a new tree structure. But
// the tree can't really manage this on its own since the structure of nodes also
// changes.
//
// New idea: tree keeps track of a map from frame numbers to a set of node
// relationships.
//
// Another idea: maybe need a more general notion of animating objects, which would
// require attaching constraints to some kind of owner. There are already constraint
// groups that modulate how constraints manifest.
//
// Here we want a notion of node position that is not tied directly to the graphical
// object itself. Then the graphical object can be animated to move between
// two node positions. We don't need a separate framework for animated objects,
// just a design pattern.

const fig1 = new Constrain.Figure("tree_anatomy")
let t
with (fig1) {
    setFontSize(10)
    function node(s) {
        return square().addText(s).setFontSize(10).setW(20).setCornerRadius(5).setFillStyle(null)
    }

    // empty tree: undefined
    // non-leaf: [root, children...]
    setConnectionStyle("intersection")
    let t = tree(l => l !== undefined ? node(l + "") : point(),
      4, [3, [6, 2, undefined], [5, [4, undefined, 9], 0]], 1)
       // t = tree(l => node(l + ""),
                   ///4, [5, 0, 2], 9)
      // t = tree(l => node(l + ""), 4, 0)

    t.addFrame(1500).rotateNodeWithParent(5)
      align("right", "top", inFrame(Frames[1], label("rotate 5 up")), margin())
    t.addFrame(1500).rotateNodeWithParent(5)
      align("right", "top", inFrame(Frames[2], label("rotate 5 up")), margin())
    t.addFrame(1500).swapNodeWithParent(0)
      align("right", "top", inFrame(Frames[3], label("bubble 0 up")), margin())
    t.addFrame(1500).swapNodeWithParent(2)
      align("right", "top", inFrame(Frames[4], label("bubble 2 up")), margin())
    t.addFrame(1500).swapNodeWithParent(2)
      align("right", "top", inFrame(Frames[5], label("bubble 2 up")), margin())

    const tgroup = t.roots.get(Frames[0]).groups.get(Frames[0])
    align("L", "TB", tgroup, margin().inset(10))
    align("abut", "B", tgroup, advanceButton(), margin().lr())

    start()
}
</script>
</html>
